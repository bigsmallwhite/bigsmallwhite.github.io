[{"categories":[],"content":"特别祝愿博客中另一位大写的人顺顺顺~~~冲冲冲~~~","date":"2020-08-13","objectID":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/","tags":[],"title":"望如我们所愿","uri":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/"},{"categories":[],"content":"2020年的疫情，着实让全球人类颤了一下…… 活着的感觉真好~😄 但是没有疾病的生活也很难…… 需要工作，需要挣钱，需要吃饭~😭 都说社会不好混…… 为啥社会的大门都这么难进~🙃 不过…… 活着的感觉真好~😄 所以…… 还是要好好努力😋 加油找到理想的工作，加油活出精彩的人生！@Y😘 ","date":"2020-08-13","objectID":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/:0:0","tags":[],"title":"望如我们所愿","uri":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/"},{"categories":["学习"],"content":"Python实现查找数组中重复的数字……","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"信息 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 ： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 ","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"思路一：哈希表 遍历所有的元素，发现不在哈希表内的元素，直接放入哈希表内，否则，return当前元素 代码如下： def findRepeatNumber(self, nums: List[int]) -\u003e int: dic = {} for i in nums: if i not in dic: dic[i] = 1 else: return i ","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:1","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"思路二：数组内查找 思路一消耗了额外的内存空间，如果要求空间复杂度为O(1)，则只能在数组内查找 由于元素的大小小于len(nums)，则可以根据列表的索引和元素一一对应的关系来查找重复，如果没有重复，那么元素就一一对应索引，否则，元素与索引就存在多对一的关系。 代码如下： def findRepeatNumber(self, nums: List[int]) -\u003e int: for index, value in enumerate(nums): if index != value: if value == nums[value]: return value # 由于交换的过程中value会变化，所以需要提前记录一下value的值 temp = value value, nums[temp] = nums[temp], value ","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:2","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"Python实现合并有序链表……","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"信息 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-\u003e2-\u003e4;1-\u003e3-\u003e4 输出：1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4 ","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/:0:0","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"思路一：迭代 合并有序链表其实和归并排序中合并有序序列一模一样，所以可以完全参照归并排序， 就是不断比较两个链表的头节点，如果某一个链表迭代完成，另一个链表还有节点，直接指向剩余的链表即可。 代码： class ListNode: def __init__(self, val=None, next=None): self.val = val self.next = next class Solution: # 迭代 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u003e ListNode: newlist = ListNode(None) # head为指向头部的游标 head = newlist while l1 and l2: if l1.val \u003c l2.val: head.next = ListNode(l1.val) l1 = l1.next else: head.next = ListNode(l2.val) l2 = l2.next # 注意游标的位置要不断后移 head = head.next # 这里可以优化一下，直接head.next = l1 or l2就行，因为有序 # head.next = l1 or l2 while l1: head.next = ListNode(l1.val) l1 = l1.next head = head.next while l2: head.next = ListNode(l2.val) l2 = l2.next head = head.next return newlist.next ","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/:1:0","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"思路二：递归 递归：递归是逆向思维，先理清逻辑关系，再返回实际结果 以[1,2,3]和[4,5,6]为例 先对比头结点1和4，很明显1放在最前面， 后面的结果如何先不管，但是逻辑上，只需要求出[2,3]和[4,5,6]的合并结果[……]，然后1--\u003e[……]即可， 继续求[……]…… 对比2和4，很明显2在前面，以此类推，具体过程如下： merge([1,2,3], [4,5,6]) 1 -- \u003e merge([2,3], [4,5,6]) ​ 2 -- \u003e merge([3], [4,5,6]) ​ 3 -- \u003e merge([], [4,5,6]) ​ [4,5,6] ==\u003e[1,2,3,4,5,6] 代码： class ListNode: def __init__(self, val=None, next=None): self.val = val self.next = next class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u003e ListNode: # 终止条件 if not l1: return l2 if not l2: return l1 if l1.val \u003c l2.val: l1.next = self.mergeTwoLists2(l1.next, l2) # 哪个链表开头就返回哪个链表 return l1 else: l2.next = self.mergeTwoLists2(l2.next, l1) return l2 可以明显发现，递归给人的感觉更加简洁，但是相对理解起来也更加有难度。 ","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/:2:0","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"Python输出集合的所有子集……","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"目标 lst = [1, 2, 3] --\u003e [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]] ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:0","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"思路一：循环 对于任何一个集合，我们先从一个空集合[[]]开始，然后一个个添加元素， 从1开始，本来是空集[[]]，加入1 --\u003e [[1]]， 但是不能忘记空集，因为[1]的所有子集为[[], [1]]， 所以加入一个1后的集合应该是[[], [1]], 加入2，需要先把2加入已经存在的每一个子集，得到[2],[1,2] 然后合并原来的集合 [[], [1], [2], [1,2]] 以此类推，新加入一个元素，合并原来所有子集，新加入一个元素，合并原来所有子集…… 最后得出 [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]] 代码如下： def allsubsets1(lst): result = [[]] if len(lst) == 0: return result for i in range(len(lst)): for item in result[:]: result.append(item+[lst[i]]) print(len(result)) return result ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:1","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"思路二：递归 递归的本质与循环相同，只不过换了一种形式， 递归是一种逆向思维， 如果想要[1, 2, 3]的所有子集，需要知道[1,2]的子集， 继而需要[1]的子集，[]的子集， 然后在最后一层的子集中加入新元素，再合并子集，加入新元素，合并子集…… 代码如下： def allsubsets2(lst): if len(lst) == 0: return [[]] else: # 这里等同于 result.append(item+[lst[i]]) return allsubsets2(lst[1:]) + [[lst[0]] + i for i in allsubsets2(lst[1:])] ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:2","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"思路三：位运算 将子集与二进制映射 0 [] –\u003e 0000 1[1] –\u003e 0001 2 [2] –\u003e 0010 3 [1, 2] –\u003e 0011 可以发现，所有子集其实就是所有元素位置为1或0的排列。 我们知道len(lst)=N的集合子集总数为2^N个， 而list(range(2^N))正好一一对应所有子集为1或0的排列。 代码如下： def allsubsets3(lst): result = [] if len(lst) == 0: return [[]] # 遍历0~2^n-1 for i in range(2 \u003c\u003c (len(lst)-1)): tmp = [] # 遍历每位是否为1 for j in range(len(lst)): if i \u003e\u003e j \u0026 1 == 0: tmp.append(lst[j]) result.append(tmp) print(len(result)) return result ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:3","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"Python位运算的用法……","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"Python位运算符 按位运算符是把数字看作二进制来进行计算的 Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13 a = 0011 1100 b = 0000 1101 ----------------- a\u0026b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 \u0026 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a \u0026 b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 (a \\| b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 « 左移动运算符：运算数的各二进位全部左移若干位，由 « 右边的数字指定了移动的位数，高位丢弃，低位补0。 a \u003c\u003c 2 输出结果 240 ，相当于a*2^2二进制解释： 1111 0000 » 右移动运算符：把\"»\"左边的运算数的各二进位全部右移若干位，» 右边的数字指定了移动的位数 a \u003e\u003e 2 输出结果 15 ，相当于a/2^2二进制解释： 0000 1111 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"应用实例 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"1 交换两个变量 # 两个相同的数异或之后结果会等于 0，即 n ^ n = 0。并且任何数与 0 异或等于它本身，即 n ^ 0 = n。 x = x ^ y // （1） y = x ^ y // （2） x = x ^ y // （3） ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"2 判断奇偶数 n \u0026 1 == 1 与 n % 2 类似 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"3 找出没有重复的数 给一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。 思想：两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下 lst = [1, 2, 3, 3, 4, 4, 2, 1, 5, 5, 6] def unique(lst): temp = lst[0] for i in range(1, len(lst)): temp ^= lst[i] return temp print(unique(lst)) ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:3","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"4 m的n次方 1、直接用pow函数 # math模块 import math math.pow(x, y) ------------------------------ #　内置的pow()方法 pow(x, y[, z]) #　函数是计算x的y次方，如果z在存在，则再对结果进行取模 #　其结果等效于pow(x,y) %z 特别注意一下 pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。 2、循环 def powxy(x, y): tmp = 1 for i in range(y): tmp *= x return tmp 时间复杂度为 O(n)，有没有其他优化的方法呢？ 3、位运算 把n转成二进制，如n=9，——\u003e1001，求m的9次方， 即m^9 = m^1000 * m^0001，所以只需要把是1的乘数累积到结果中 如2^9，拆分为1000，0001（8,1） def powerXn(x, n): result = 1 temp = x while n != 0: if n \u0026 1 == 1: result *= temp temp *= temp n \u003e\u003e= 1 return result 4、递归 递归计算幂方，二分优化，2^6 = 2^3*2^3，故可以二分求幂 def powerXn(x, n): if n == 0: return 1 else: temp = powerX1(x, n//2) result = temp * temp if n % 2 == 1: result *= x return result ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:4","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"5 不大于N的最大2的幂指数 传统的做法就是让1不断着乘以 2，代码如下： def findN(n): sum = 1 while True: if sum * 2 \u003e n: return sum sum *= 2 时间复杂度是O(logn)，还有其他优化的方法吗？ 采用位运算：例如 N = 19，那么转换成二进制就是 00010011。那么我们要找的数就是，把二进制中最左边的1保留，后面的 1 全部变为 0。即我们的目标数是 00010000 1、找到最左边的 1，然后把它右边的所有 0 变成 1 2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。 3、把得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 » 1 = 00010000。 具体的做法为： n |= n \u003e\u003e 1 n |= n \u003e\u003e 2 n |= n \u003e\u003e 4 n |= n \u003e\u003e 8 我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去…. 完整代码： def findN(n): n |= n \u003e\u003e 1 n |= n \u003e\u003e 2 n |= n \u003e\u003e 4 n |= n \u003e\u003e 8 return(n+1) \u003e\u003e 1 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:5","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"6 输出集合的子集 以lst = [1,2,3,4]为例，将子集与二进制映射。可以发现，所有子集其实就是所有元素位置为1或0的排列。我们知道len(lst)=N的集合子集总数为2^N个，而list(range(2^N))正好一一对应所有子集为1或0的排列。 0 [] --\u003e 0000 1 [1] --\u003e 0001 2 [2] --\u003e 0010 3 [1, 2] --\u003e 0011 4 [3] --\u003e 0100 5 [1, 3] --\u003e 0101 6 [2, 3] --\u003e 0110 7 [1, 2, 3] --\u003e 0111 8 [4] --\u003e 1000 9 [1, 4] --\u003e 1001 10 [2, 4] --\u003e 1010 11 [1, 2, 4] --\u003e 1011 12 [3, 4] --\u003e 1100 13 [1, 3, 4] --\u003e 1101 14 [2, 3, 4] --\u003e 1110 15 [1, 2, 3, 4] --\u003e 1111 具体的代码： def findsubsets(lst): N = len(lst) for i in range(2 ** N):#子集的个数 subset = [] for j in range(N):#用来判断二进制数的下标为j的位置的数是否为1 if (i \u003e\u003e j) \u0026 1: subset.append(lst[j]) print(subset) ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:6","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"Python高级函数filter、map、reduce……","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":" filter、map、reduce，都是对一个集合进行处理，filter 用于过滤，map 用于映射，reduce 用于归并。是 Python 列表方法的三架马车。 ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:0:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"1 filter filter会根据提供的函数对指定序列做过滤。 filter 函数的定义：filter(function or None, sequence) -\u003e list, tuple, or string function 是一个谓词函数，接受一个参数，返回布尔值 True 或 False。 filter 函数会对序列参数 sequence 中的每个元素调用 function 函数，最后返回的结果包含调用结果为 True 的元素。 返回值的类型和参数 sequence 的类型相同 比如返回序列中的所有偶数： def is_even(x): return x \u0026 1 != 0 filter(is_even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \u003e\u003e\u003e[1, 3, 5, 7, 9] 注意 如果 function 参数为 None，返回结果和 sequence 相同。 filter(None, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \u003e\u003e\u003e[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:1:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"2 map map 函数会根据提供的函数对指定序列做映射。 map 函数的定义：map(function, sequence[, sequence, ...]) -\u003e list 通过定义可以看到，这个函数的第一个参数是一个函数，剩下的参数是一个或多个序列，返回值是一个集合。 function 可以理解为是一个一对一或多对一函数，map 的作用是以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的 list。 比如要对一个序列中的每个元素进行平方运算： map(lambda x: x ** 2, [1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] 在参数存在多个序列时，会依次以每个序列中相同位置的元素做参数调用 function 函数。 比如要对两个序列中的元素依次求和。 map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) map 返回的 list[0] :参数序列 1 的第一个元素加参数序列 2 中的第一个元素 (1 + 2) list[1]:参数序列 1 中的第二个元素加参数序列 2 中的第二个元素 (3 + 4) …… 依次类推，最后的返回结果为：[3, 7, 11, 15, 19] 要注意 function 函数的参数数量，要和 map 中提供的集合数量相匹配。 而且如果集合长度不相等，会以最小长度对所有集合进行截取。 技巧 当函数为 None 时，操作和 zip 相似： map(None, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) \u003e\u003e\u003e[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)] ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:2:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"3 reduce reduce 函数会对参数序列中元素进行累积 reduce 函数的定义：reduce(function, sequence[, initial]) -\u003e value function 参数是一个有两个参数的函数，reduce 依次从 sequence 中取一个元素，和上一次调用 function 的结果做参数再次调用 function。 注意 第一次调用 function 时，如果提供 initial 参数，会以 sequence 中的第一个元素和 initial 作为参数调用 function，否则会以序列 sequence 中的前两个元素做参数调用 function。 from functools import reduce #已经从全局命名空间删除，需要从functools导入 reduce(lambda x, y: x + y, [2, 3, 4, 5, 6], 1) #1为initial参数 结果为 21 ((((((1+2)+3)+4)+5)+6)) reduce(lambda x, y: x + y, [2, 3, 4, 5, 6]) 结果为 20 注意 function 函数不能为 None。 ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:3:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"4 应用实例 4.1、用 map 和 reduce 实现 5 的阶乘相加（5!+4!+3!+2!+1!） \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,6))) 120 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,5))) 24 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,4))) 6 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,3))) 2 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,2))) 1 把上一步的结果变成一个阶乘列表 \u003e\u003e\u003eprint(map(lambda a:reduce(lambda x,y:x*y,range(1,a+1)),range(1,6))) [1, 2, 6, 24, 120] 最后把阶乘列表相加，第一题解决 \u003e\u003e\u003eprint(reduce(lambda m,n:m+n,map(lambda a:reduce(lambda x,y:x*y,range(1,a+1)),range(1,6)))) 153 4.2、用 filter 将 100~200 以内的质数过滤出来 质数，又称素数，指在一个大于 1 的自然数中，除了 1 和此整数自身外，不能被其他自然数整除的数 \u003e\u003e\u003elist(filter(lambda x:len(list(filter(lambda y:x%y==0,range(2,int(x**0.5)+1))))==0,range(23,30))) #不能直接对迭代器使用len()函数，先转化为list ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:4:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"Linux挂载的解释……","date":"2020-08-08","objectID":"/linux%E6%8C%82%E8%BD%BD/","tags":["Linux"],"title":"Linux挂载","uri":"/linux%E6%8C%82%E8%BD%BD/"},{"categories":["学习"],"content":"信息 名词解释： 挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。 Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中，输入 tree /即可查看 在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构） 当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为linux所用。合二为一的过程称为“挂载”。 注意 Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,...）。比如插入U盘后，系统自动分配I或E或者其他的盘符，盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载：unmount。 问题 Linux下，不像Windows可以有C,D,E多个目录，Linux只有一个根目录/。在装系统时，分配给linux的所有区都在/下的某个位置，比如/home等等。 具体挂载的过程看下面的例子 示例 以插入硬盘为例，假如插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/，如图所示： 目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。 虽然可以在一些Linux图形桌面系统里找到位置，浏览管理里面的文件，但在命令行却不知道怎么访问，比如无法使用cd或者ls。更无法在编程时指定一个目录对其操作。 接下来，我们在根目录下新建一个目录 /sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，如图所示： 挂载命令：mount /sdb1 /sdb-u 把U盘的区sdb1挂载到Linux根目录的/sdb-u文件夹下，之后访问这个/sdb-u文件夹就相当于访问这个U盘了。对/sdb-u的任何操作，都相当于对U盘里文件的操作。 所以直白讲，Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上，访问这个目录就是访问该存储设备。 linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。 要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。 挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。 问题 插入U盘后不是自动分盘到/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？ /sdb1不是目录。可以发现ls /sdb1无法执行。/sdb1是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，也不知道如何对它们操作。 技巧 插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在系统的/media/cdrom中对CD中的内容进行管理。 ","date":"2020-08-08","objectID":"/linux%E6%8C%82%E8%BD%BD/:0:0","tags":["Linux"],"title":"Linux挂载","uri":"/linux%E6%8C%82%E8%BD%BD/"},{"categories":["学习"],"content":"SQL的学习笔记……","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"1、了解SQL SQL：Structured Query Language（结构 化查询语言）的缩写。 SQL 是一种专门用来与数据库沟通的语言。 注意 主键（primary key）： 一列（或一组列），其值能够唯一标识表中每一行。 任意两行都不具有相同的主键值； 每一行都必须具有一个主键值（主键列不允许 NULL 值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:1:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"2、检索数据 select column_name1, column_name2, ... -- '*'用来检索所有列 from table -- SQL 语句不区分大小写 -- distinct column_name 检索去重后的结果 注意：不能部分使用 DISTINCT DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例 如，你指定 SELECT DISTINCT vend_id, prod_price，除非指定的 两列完全相同，否则所有的行都会被检索出来。 -- limit m, n 表示从m+1行开始，偏移n行 MySQL和 MariaDB支持简化版的 LIMIT 4 OFFSET 3 语句，即 LIMIT 3,4。 使用这个语法，逗号之前的值对应 OFFSET，逗号之后的值对应 LIMIT。 第一个被检索的行是第 0 行，而不是第 1 行。因此， LIMIT 1 OFFSET 1 会检索第 2 行，而不是第 1 行。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:2:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"3、排序检索数据 order by 注意： ORDER BY 子句的位置 在指定一条 ORDER BY 子句时，应该保证它是 SELECT 语句中最后一条子句 按多个列排序 order by column_name1, column_name2 仅在多个行具有相同的 column_name1 值时才对产品按 column_name2 进行排序。如果 column_name1 列中所有的值都是唯一的，则不会按 column_name2 排序。 多个列排序时还可以采用相对位置来排序，order by 2, 3 -- 2,3代表第2列和第3列 排序 默认：ASC，升序排列 DESC 关键字只应用到直接位于其前面的列名，如果想在多个列上进行降序排序，必须对每一列指定 DESC 关键字。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:3:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"4、过滤数据 在 SELECT 语句中，数据根据 WHERE 子句中指定的搜索条件进行过滤 在同时使用 ORDER BY 和 WHERE 子句时，应该让 ORDER BY 位于WHERE 之后 范围内查询 between ... and ... -- 数值或者日期范围内查询 select column_name1, column_name2 from table where column_name2 between 5 and 10; -- BETWEEN 匹配范围中所有的值，包括指定的开始值和结束值。 确定值是否为 NULL，不能简单地检查是否= NULL， 用is null 判断 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:4:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"5、高级数据过滤 组合where语句： SQL 允许给出多个 WHERE 子句。这些子句有两种使用方式，即以 AND 子句或 OR 子句的方式使用， and优先级高 IN 操作符后跟由逗号分隔的合法值，这些值必须括在圆括号中 信息 为什么要使用 IN 操作符？其优点如下 在有很多合法选项时， IN 操作符的语法更清楚，更直观。 在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。 IN 操作符一般比一组 OR 操作符执行得更快。 IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立 WHERE 子句。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"6、用通配符进行过滤 匹配like开头的字符 like 'like%' %代表搜索模式中给定位置的 0 个、 1 个或多个字符。 注意： NULL通配符%看起来像是可以匹配任何东西，但有个例外，这就是 NULL。 子句 WHERE prod_name LIKE '%' 不会匹配产品名称为 NULL 的行。 另一个有用的通配符是下划线（ _）。 下划线的用途与%一样，但它只匹配单个字符，而不是多个字符。 -- 说明：Access 通配符如果使用的是 Microsoft Access，需要使用 ?而不是_。 方括号（ [] ）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。 说明：并不总是支持集合与前面描述的通配符不一样，并不是所有 DBMS 都支持用来创建集合的[]。 只有微软的 Access 和 SQL Server 支持集合。 WHERE cust_contact LIKE '[JM]%' -- 找出所有名字以 J 或 M 起头的联系人 此通配符可以用前缀字符 ^（脱字号）来否定。 例如，下面的查询匹配以J 和 M 之外的任意字符起头的任意联系人名（与前一个例子相反） WHERE cust_contact LIKE '[ ^JM]%' -- 以J 和 M 之外的任意字符起头的任意联系人名 可以用not 代替 WHERE NOT cust_contact LIKE '[JM]%' 注意 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用 其他操作符。 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:6:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"7、创建计算字段 将值联结到一起（将一个值附加到另一个值）构成单个值。 根据你所使用的 DBMS，此操作符可用加号（ +）或两个竖杠（ || ）表示。 在 MySQL 和 MariaDB 中，必须使用特殊的函数。 -- Access 和 SQL Server 使用 +号。 DB2、 Oracle、 PostgreSQL、 SQLite 和Open Office Base 使用 || 如： SELECT vend_name + ' (' + vend_country + ')' --或 SELECT vend_name || ' (' || vend_country || ')' FROM Vendors ORDER BY vend_name; 下面是使用 MySQL 或 MariaDB 时需要使用的语句： SELECT Concat(vend_name, ' (', vend_country, ')') -- 按顺序放在concat函数内 FROM Vendors ORDER BY vend_name; --大多数 DBMS 都支持 RTRIM()（正如刚才所见，它去掉字符串右边的空格） --LTRIM()（去掉字符串左边的空格） --以及 TRIM()（去掉字符串左右两边的空格 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:7:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"8、使用函数处理数据 UPPER()将文本转换为大写 LEFT()（或使用子字符串函数） 返回字符串左边的字符 LENGTH()（也使用DATALENGTH()或LEN()） 返回字符串的长度 LOWER()（ Access使用LCASE()） 将字符串转换为小写 LTRIM() 去掉字符串左边的空格 RIGHT()（或使用子字符串函数） 返回字符串右边的字符 RTRIM() 去掉字符串右边的空格 SOUNDEX() 返回字符串的SOUNDEX值 --发音相似 WHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green') UPPER()（ Access使用UCASE()） 将字符串转换为大写 日期：WHERE strftime('%Y', order_date) = '2012'; ABS() 返回一个数的绝对值 COS() 返回一个角度的余弦 EXP() 返回一个数的指数值 PI() 返回圆周率 SIN() 返回一个角度的正弦 SQRT() 返回一个数的平方根 TAN() 返回一个角度的正切 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:8:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"9、汇总数据 AVG() 返回某列的平均值 -- AVG()函数忽略列值为 NULL 的行 COUNT() 返回某列的行数 -- 使用 COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（ NULL）还是非空值。 -- 使用 COUNT(column)对特定列中具有值的行进行计数， 忽略 NULL 值 MAX() 返回某列的最大值 -- MAX()函数忽略列值为 NULL 的行 MIN() 返回某列的最小值 -- MIN()函数忽略列值为 NULL 的行 SUM() 返回某列值之和 -- 如SELECT SUM(item_price*quantity) AS total_price， SUM()函数忽略列值为 NULL 的行 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:9:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"10、分组数据 GROUP BY 子句和 HAVING 子句 如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组 WHERE 在数据分组前进行过滤， HAVING 在数据分组后进行过滤，WHERE 排除的行不包括在分组中 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:10:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"11、使用子查询 SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num -- WHERE order_num IN (20007,20008) FROM OrderItems WHERE prod_id = 'RGAN01'); 对于检索出的每个顾客，统计其在 Orders 表中的订单数目 SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders FROM Customers ORDER BY cust_name; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:11:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"12、联结表 可以联结多个表返回一组输出，联结在运行时关联表中正确的行 子查询可以用联接表实现，联接表需要注意where条件语句，否则返回为笛卡尔积 SELECT prod_name, vend_name, prod_price, quantity FROM OrderItems, Products, Vendors WHERE Products.vend_id = Vendors.vend_id AND OrderItems.prod_id = Products.prod_id AND order_num = 20007; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:12:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"13、创建高级联接 子查询： SELECT cust_id, cust_name, cust_contact FROM Customers WHERE cust_name = (SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones') 联接查询： SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM Customers AS c1, Customers AS c2 WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones'; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:13:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"14、组合查询 利用 UNION 操作符将多条 SELECT 语句组合成一个结果集 SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN ('IL','IN','MI') UNION SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = 'Fun4All'; --使用 UNION 时，重复的行会被自动取消。使用 UNION ALL， DBMS 不取消重复的行 注意 UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键 字 UNION 分隔（因此， 如果组合四条 SELECT 语句，将要使用三个 UNION 关键字）。 UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过， 各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含 转换的类型（例如，不同的数值类型或不同的日期类型） ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:14:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"15、数据插入 insert into table(a, b, c) values('xx', 'xx', 'xx') INSERT INTO Customers VALUES('1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL); --提示：插入多行 INSERT 通常只插入一行。要插入多行，必须执行多个 INSERT 语句。 INSERT SELECT是个例外，它可以用一条 INSERT插入多行，不管 SELECT语句返回多少行，都将被 INSERT 插入 select * into b from a -- 把a数据复制到b ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:15:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"16、更新和删除数据 利用 UPDATE 和 DELETE 语句进一步操作表数据 update table set xx=xx where ... UPDATE Customers SET cust_email = 'kim@thetoystore.com' WHERE cust_id = '1000000005'; --删除一行 DELETE FROM Customers WHERE cust_id = '1000000006'; DELETE 语句从表中删除行，甚至是删除表中所有行。但是， DELETE不删除表本 --删除一列 alter table 表名 drop column 列名 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:16:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"17、创建和操纵表 create table table_name( column_name1 type, column_name2 type, ... ); CREATE TABLE Products ( prod_id CHAR(10) NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL, prod_desc VARCHAR(1000) NULL ); 更改表结构 增加一列：ALTER TABLE VendorsADD vend_phone CHAR(20); 删除一列：ALTER TABLE Vendors DROP COLUMN vend_phone; 删 除 表：DROP TABLE CustCopy； 重命名表：rename table old_name to new_name; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:17:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"18、使用视图 视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据 注意：性能问题 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。 如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。 因此，在部署使用了大量视图的应用前，应该进行测试。 1、与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字） 2、对于可以创建的视图数目没有限制 3、视图不能索引，也不能有关联的触发器或默认值 视图用 CREATE VIEW 语句来创建 DROP VIEW viewname 删除视图 视图一般是一个复杂的sql查询 -- create view view_name as select ...... CREATE VIEW ProductCustomers AS SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; 视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。 视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理， 重新格式化或保护基础数据 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:18:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"19、使用存储过程 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。 存储过程可封装，并隐藏复杂的商业逻辑。 存储过程可以回传值，并可以接受参数。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:19:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"20、事务管理 事务（ transaction）指一组 SQL 语句； 回退（ rollback）指撤销指定 SQL 语句的过程； 提交（ commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（ savepoint）指事务处理中设置的临时占位符（ placeholder）， 可以对它发布回退（与回退整个事务处理不同）。 使用简单的 ROLLBACK 和 COMMIT 语句，就可以写入或撤销整个事务。但 是，只对简单的事务才能这样做，复杂的事务可能需要部分提交或回退。在 SQL 中，这些占位符称为保留点。在 MariaDB、 MySQL 和 Oracle 中 创建占位符，可使用 SAVEPOINT 语句。 ....... savepoint my_savepoint1 ....... savepoint my_savepoint2 ....... rollback to my_savepoint1 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:20:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"21、使用游标 游标是面向集合与面向行的设计思想之间的一种桥梁，主要用在循环处理、存储过程、函数中使用，用来查询结果集 游标的使用一般分为 5 个步骤，主要是：定义游标 -\u003e 打开游标 -\u003e 使用游标 -\u003e 关闭游标 -\u003e 释放游标。 （1）定义游标 语法为： DECLARE \u003c游标名\u003e CURSOR FOR select语句; 具体例子： DECLARE mycursor CURSOR FOR select * from shops_info; -- 这样游标就对select语句声明了一个游标 （2）打开游标 open \u003c游标名\u003e （3）使用游标 使用游标需要用关键字 fetch 来取出数据，然后取出的数据需要有存放的地方，我们需要用 declare 声明变量存放列的数据其语法格式为： declare 变量1 数据类型(与列值的数据类型相同) declare 变量2 数据类型(与列值的数据类型相同) declare 变量3 数据类型(与列值的数据类型相同) FETCH [NEXT | PRIOR | FIRST | LAST] FROM \u003c游标名\u003e [ INTO 变量名1,变量名2,变量名3[,…] ] NEXT： 取下一行的数据，游标一开始默认的第一行之前， 故要让游标指向第一行，就必须第一次就执行 FETCH NEXT 操作 INTO：将一行中每个对应的列下的数据放到与列 的数据类型相同的变量中。 -- 声明四个变量 declare id varchar(20); declare pname varchar(20); declare pprice varchar(20); declare pdescription varchar(20); 总结： 1、定义一个游标mycursor declare mycursor cursor forselect *from shops_info; 2、打开游标： open mycursor; 3、使用游标获取列数据放入变量中 fetch next from mycursor into id,pname,pprice,pdescription; 4、关闭游标：很简单的使用语句： close mycursor; 5、释放游标： deallocate mycursor; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"22、高级SQL特性 高级数据处理特性： 约束、 索引和触发器 检查约束 CREATE TABLE OrderItems ( order_num INTEGER NOT NULL, order_item INTEGER NOT NULL, prod_id CHAR(10) NOT NULL, quantity INTEGER NOT NULL CHECK (quantity \u003e 0), --检查保证 quantity大于 0。 item_price MONEY NOT NULL ); 检查名为 gender 的列只包含 M 或 F，可编写如下的 ALTER TABLE 语句： ADD CONSTRAINT CHECK (gender LIKE '[MF]') 触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发 器可以与特定表上的 INSERT、 UPDATE 和 DELETE 操作（或组合）相关联。 sql serve版本： CREATE TRIGGER customer_state ON Customers FOR INSERT, UPDATE AS UPDATE Customers SET cust_state = Upper(cust_state) WHERE Customers.cust_id = inserted.cust_id; 一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:22:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"经典十大排序算法的Python实现……","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"本文是关于经典排序算法的个人学习记录……，文字部分网上都有，算是个人总结复制粘贴，重点在代码部分。 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"概述 排序算法是《数据结构与算法》中最基本的算法之一。 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 用一张图概括： 关于时间复杂度： 平方阶 (O (n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序； 线性对数阶 (O (nlog2n)) 排序 快速排序、堆排序和归并排序； O (n1+§)) 排序，§ 是介于 0 和 1 之间的常数。希尔排序； 线性阶 (O (n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 排序后 2 个相等键值的顺序和排序之前它们的顺序相同 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶” 的个数 In-place：占用常数内存，不占用额外内存，原地算法，仅靠输出覆盖输入，即对原数组进行操作 Out-place：占用额外内存 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"1 冒泡排序 冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。 （1）算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 （2）动图演示 （3）python 代码 '''前后两个对比，一次排出一个最值放在最后''' def bubble_sort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] else: continue return arr 技巧 立个flag '''优化：每次循环后需要监测是否发生了数据交换，如果没有，则可以提前结束排序''' def bubble_sort_plus(arr): for i in range(1, len(arr)): flag = True for j in range(0, len(arr)-i): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] flag = False else: continue if flag: break return arr 每次循环时记录最后一次交换的位置 '''常见的数据中大部分是部分有序，尾部部分有序的数据更多，可以继续优化： 每次循环时记录最后一次交换的位置，位置之后的说明部分有序，不需要再交换了，只对前面的数据排序''' def bubble_sort_plus2(arr): end = len(arr) start = 1 while start \u003c end: sorted_index = 0 #初始值为0是为了已排序列表，保证一次循环就结束 for j in range(0, end-start): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] sorted_index = j+1 #记录截止排序的地方，即后面全是有序列表， start = 0 #记录之后，start为0，保证下次循环，end-start可以取到记录之前所有的数 end = sorted_index #记录赋值给end，保证while循环次数中去掉记录之后的循环 start += 1 #正常循环递增 return arr bubble_sort_plus2(arr) \"\"\"冒泡排序算法是稳定，但是如果把比较过程的\u003c写出\u003c=就会导致不稳定\"\"\" ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"2 选择排序 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O (n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。 （1）算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 （2）动图演示 （3）python代码 '''每次循环选择剩余数组中的最小值，在左侧排列好''' def select_sort(arr): for i in range(len(arr)): min_index = i for j in range(i+1, len(arr)): if arr[j] \u003c arr[min_index]: min_index = j if i != min_index: arr[i], arr[min_index] = arr[min_index], arr[i] return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"3 堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。其实是对选择排序的一种优化，把内部循环寻找最值的工作交给堆结构 （1）算法步骤 创建一个堆 H [0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down (0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 （2）动图演示 （3）python代码 '''借用堆结构，利用大顶堆筛选出最值，弹出最值，递归剩余数组，不断弹出最值''' def heapify(arr, n, i): large = i left = 2 * i + 1 right = 2 * i + 2 if left \u003c n and arr[large] \u003c arr[left]: large = left if right \u003c n and arr[large] \u003c arr[right]: large = right if large != i: arr[i], arr[large] = arr[large], arr[i] heapify(arr, n, large) def heap_sort(arr): n = len(arr) for i in range(n//2, -1, -1): #从最后一个非根节点开始，由下到上，逐渐堆化 heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) #每次交换最大值和末尾值后，需要对0节点进行shiftdown操作，重新堆化 return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"4 插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 （1）算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） （2）动图演示 （3）python 代码 '''右侧未排序的不断与已排序的左侧逐一比较，小于则已排序的往后移一位''' def insert_sort(arr): for i in range(1,len(arr)): pre_index = i-1 current = arr[i] #记录当前值 while pre_index \u003e= 0 and arr[pre_index] \u003e current: arr[pre_index+1] = arr[pre_index] #这里直接用大数往后挪位，而不是采用交换（交换一次实际需要执行三次赋值操作），可以减少代码执行，提高效率 pre_index -= 1 arr[pre_index+1] = current return arr 技巧 继续优化插入排序：由于插入的过程中前面已经有序，可以利用二分搜索计算插入的位置，而不是一个个比较，但是挪动的次数不变，只是比较的次数减少，所以时间复杂度依然是O(n^2)。同时还要注意的是：2,4,5,6,6,6,6,7,9,6，如果把最后一个6插入前面，如果只是用二分搜索，可能导致算法不稳定（因为二分计算的索引不确定），所以需要有所改动，在原来二分搜索的基础上，计算第一个比插入值大的值的索引，即：7的索引，如图所示，在原来二分搜索的基础上，把=m的情况归并到\u003em的情况中，最后迭代到begin=end，返回begin或end。 二分搜索时，begin和end的位置一般是左闭右开[begin,end)，end一般是超出列表索引后一位，即等于列表长度，目的是可以算出中间元素的个数=end-begin，如图所示： 二分搜索的代码： '''二分搜索一般用来查找有序数列中某一数字的位置，代码如下''' arr = [0,1,2,3,4,5,6,7,8,9,10] num = 10 def binary_search(arr, num): ''' arr:搜索的列表 num:搜索的数 ''' begin = 0 end = len(arr) while begin \u003c end: mid = (begin+end) // 2 if num \u003e arr[mid]: begin = mid + 1 elif num \u003c arr[mid]: end = mid else: return mid return -1 binary_search(arr, num) 插入排序二分搜索优化如图： 优化的代码如下： def binary_search(arr, index): begin = 0 end = index while begin \u003c end: mid = (begin+end) // 2 if arr[index] \u003e= arr[mid]: begin = mid + 1 else: end = mid return begin #其实最后的begin和end相等，也就是待插入的索引位置 def insert_sort(arr): for i in range(1,len(arr)): current = arr[i] insert_index = binary_search(arr, i) while i \u003e insert_index: #对当前索引和插入索引之间的数据进行挪位 arr[i] = arr[i-1] i -= 1 arr[insert_index] = current return arr insert_sort(arr[:]) ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"5 希尔排序 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； （1）算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti \u003e tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 （2）动图演示 （3）Python 代码 '''分组采用插入排序，步长逐渐减小，为1时已经大部分有序，再经过最后一次插入排序；不稳定''' def shell_sort(arr): gap = len(arr) // 2 while gap \u003e 0: for i in range(gap, len(arr)): temp = arr[i] j = i - gap while j \u003e= 0 and arr[j] \u003e temp: arr[j+gap] = arr[j] j -= gap arr[j+gap] = temp gap //= 2 return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"6 归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O (nlogn) 的时间复杂度。代价是需要额外的内存空间。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法） 自下而上的迭代 （1）算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 （2）动图演示 （3）python代码 '''分而治之，迭代分组后，不同分组排序后归并，需要申请额外的存储空间''' def merge_sort(arr): if len(arr)\u003c2: return arr mid = len(arr) // 2 left, right = arr[:mid], arr[mid:] return merge(merge_sort(left), merge_sort(right)) def merge(left, right): result = [] while left and right: if left[0] \u003c right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) while left: result.append(left.pop(0)) while right: result.append(right.pop(0)) return result ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"7 快速排序 快速排序是由东尼・霍尔所发展的一种排序算法。快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 信息 快速排序虽然 Worst Case 的时间复杂度达到了 O (n²)，但是在大多数情况下都比平均时间复杂度为 O (n logn) 的排序算法表现要更好，在《算法艺术与信息学竞赛》上的解释：快速排序的最坏运行情况是 O (n²)，比如说顺序数列的快排。但它的平摊期望时间是 O (nlogn)，且 O (nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O (nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 （1）算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； （2）动图演示 （3）python 代码 '''一、随机挑选一个基准，然后根据分大小区，迭代上述，把分区和基准连接在一起返回 本质就是把每一个元素转换成轴点元素，数组就排好序了''' def quick_sort(arr): if len(arr) \u003c= 1: return arr else: pivot = arr[0] left = [x for x in arr[1:] if x \u003c pivot] right = [x for x in arr[1:] if x \u003e= pivot] return quick_sort(left) + [pivot] + quick_sort(right) 在原数组上进行交换 '''二、在原数组上进行交换的写法''' def quick_sort(arr): sort(0, len(arr)) #对[0,len(arr))范围内的数组进行排序 def sort(begin, end): if end-begin \u003c 2: return mid = pivotIndex(begin, end) sort(begin, mid) sort(mid+1, end) def pivotIndex(begin, end): pivot = arr[begin] #以第一个元素为轴点 end -= 1 while begin \u003c end: '''需要来回左右比较判断，可以用while嵌套''' while begin \u003c end: if arr[end] \u003e pivot: end -= 1 else: arr[begin] = arr[end] begin += 1 break while begin \u003c end: if arr[begin] \u003c pivot: begin += 1 else: arr[end] = arr[begin] end -= 1 break arr[begin] = pivot return begin 具体过程如图： 最坏情况是O(n^2)，如图所示： 技巧 为了防止出现上述最坏的时间复杂度，我们需要随机选取轴点元素，这里操作的方法是，随机选取数组中的元素和begin位置的元素进行调换即可。 import random '''三、在原数组上进行交换的写法，加上随机选取轴点数据''' def quick_sort(arr): sort(0, len(arr)) #对[0,len(arr))范围内的数组进行排序 def sort(begin, end): if end-begin \u003c 2: return mid = pivotIndex(begin, end) sort(begin, mid) sort(mid+1, end) def pivotIndex(begin, end): '''随机选取元素与begin位置元素交换''' pivot = random.choice(arr) #以第一个元素为轴点 end -= 1 while begin \u003c end: '''需要来回左右比较判断，可以用while嵌套''' while begin \u003c end: if arr[end] \u003e pivot: end -= 1 else: arr[begin] = arr[end] begin += 1 break while begin \u003c end: if arr[begin] \u003c pivot: begin += 1 else: arr[end] = arr[begin] end -= 1 break arr[begin] = pivot return begin 虽然与轴点相等的元素可以放在任意一边，但是最好将与轴点相等的元素扔到对面的分组，这样可以保持分组的均匀，否则分组可能非常不均匀，最后的时间复杂度就很高。 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"8 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 （1）动图演示 （2）Python 代码 '''针对有确定范围的整数数组，统计不同整数的个数存放在额外的存储空间，按整数大小排序''' def count_sort(arr): bucket_len = max(arr) + 1 bucket = [0] * bucket_len sort_index = 0 for i in range(len(arr)): bucket[arr[i]] += 1 for j in range(bucket_len): while bucket[j] \u003e 0: arr[sort_index] = j sort_index += 1 bucket[j] -= 1 return arr 技巧 上面的方法无法对负整数排序，极其浪费内存空间并且不稳定 节省空间\u0026对负整数排序 #节省空间\u0026对负整数排序：max-min+1 def count_sort(arr): buckets = [0] * ((max(arr) - min(arr))+1) min_num = min(arr) for i in range(len(arr)): buckets[arr[i]-min_num] += 1 res=[] for i in range(len(buckets)): if buckets[i] != 0: res += [i+min(arr)]*buckets[i] return res 稳定排序 ''' 稳定排序:稳定排序需要遍历原数组， 同时需要记录该元素前面元素的个数（就是本元素的索引）， 所以现在不是记录每个元素的个数，而是记录小于等于该元素的个数， 如[2,3,5,1,5,7,8],则新建的索引为每个元素-最小值（k-min）， 每个索引对应是值为\u003c=k的元素数（原来是=k），从右往左依次遍历原数组， 如8，索引为7，值为7，排序后的索引为7-1，右边的5：索引为4， 值为5， 排序后的索引为5-1， 左边的5：索引和值相同，排序后的索引为5-1-1， 从右往左遍历保证了稳定性。 ''' def count_sort(arr): buckets = [0] * ((max(arr) - min(arr))+1) min_num = min(arr) for i in range(len(arr)): buckets[arr[i]-min_num] += 1 for j in range(1, len(buckets)): buckets[j] = buckets[j] + buckets[j-1] res=[0] * len(arr) for k in range(len(arr)-1, -1, -1): res[buckets[arr[k]-min_num]-1] = arr[k] buckets[arr[k]-min_num] -= 1 return res ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"9 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快：当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢：当输入的数据被分配到了同一个桶中。 （1）Python 代码 '''将数组分到顺序的桶内（划分范围）,对桶内数据排序后，合并在一起''' def heap_sort(arr): min_num = min(arr) max_num = max(arr) bucket_range = (max_num - min_num) / len(arr) bucket_list = [[] for i in range(len(arr)+1)] for i in arr: bucket_list[int((i-min_num) // bucket_range)].append(i) arr.clear() for i in bucket_list: arr += sorted(i) return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"10 基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数（低位到高位）分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 由于每位数的取值范围是固定的0~9，所以针对每次排序，可以用计数排序 信息 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； （1）动图演示 （2）python 代码 '''针对比较集中的整数数组，分别根据不同位上的数分箱（0~9）,然后排序，递归上述步骤''' def radix_sort(arr): i = 0 n = 1 max_num = max(arr) while max_num \u003e 10 ** n: n += 1 while i \u003c n: bucket = {} for x in range(10): bucket.setdefault(x, []) for y in arr: radix = int(y / (10**i) % 10) bucket[radix].append(y) arr.clear() for j in range(10): if len(bucket[j]) != 0: arr += bucket[j] i += 1 return arr 信息 未完待续…… ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"11 Timsort ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:12:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"12 休眠排序 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:13:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"13 拓扑排序 …… ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:14:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["logs"],"content":"人长大了，感情就淡了……","date":"2020-08-04","objectID":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/","tags":[],"title":"长大的烦恼","uri":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/"},{"categories":["logs"],"content":"人长大了，感情就淡了…… 多次发现曾经很要好的人，已经许久不再联系。 拿起手机发个消息，突然发现大家都不在是以前的大家。 我以为我的突然问候能让彼此回想起很多事。 事实却是感情淡了，更多的是尬聊。 大家，还有我，都有了新的圈子。 好像每个人都在变。 唯一不变的就是我们都在变。 还是不要再自作多情。 过好自己最重要。 以前的自己多么幼稚，希望今后越来越成熟， 不要倾诉太多，不要掏心掏肺。 毕竟以后…… 我们不再是以前的我们。 ","date":"2020-08-04","objectID":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/:0:0","tags":[],"title":"长大的烦恼","uri":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/"},{"categories":[],"content":"这是一个关于个人的学习记录和生活日常的博客小站~","date":"2020-08-04","objectID":"/about/","tags":[],"title":"关于本博客","uri":"/about/"},{"categories":[],"content":"好好学习，天天向上 摘要 信息 本人是个半宅男，爱好电子产品、游戏、动漫、肥宅快乐水…… 一直都不爱写笔记，不管是在读书上课或者自学软件和技术，都觉得记笔记是一件十分耽误时间的事，更重要的是笔记就特别像手机里的照片，舍不得删，也一直不看……😂 但随着学习的东西越来越多，发现如果在学习的时候不输出一点笔记和总结，那学习新的东西真的痛苦，学这忘那是常事，互相记混才是真的烦……😩 所以……，好好记笔记吧，养成喜欢记笔记和总结的好习惯，是真的香！！！🤙 而且，笔记中穿插着个人总结，会让你不自觉中对学习的内容掌握地更加熟练……， 因此，本着好好学习，天天向上的乐观向上自我催眠主义，搭建了这个博客，感谢LoveIt主题 这里推荐一下笔记的工具和笔记分享途径 markdown：非常方便且好看的文本格式 typora（Vscode）：大力推荐的编辑markdown工具 hugo：大力推荐的静态网页生成工具 github（gitlab）：代码仓库以及网页访问（gitpage） 当然了，博客的作用当然不仅仅是分享笔记，生活常事、所见所闻、学习记录、心中所感这些都可以分享，分享是一件快乐的事……🤗 ","date":"2020-08-04","objectID":"/about/:0:0","tags":[],"title":"关于本博客","uri":"/about/"},{"categories":["学习"],"content":"个人的一些算法学习记录和总结……","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"注意 多看、多想、多做、多练、多总结！！！ ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:0:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"1 辗转相除法求最大公约数 原理： 两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。具体可见wiki 例如，252 和 105 的最大公约数是 21；因为 252 − 105 = 21 × (12 − 5) = 147 所以 147 和 105 的最大公约数也是 21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 21 = 5 × 105 + (−2) × 252 。这个重要的结论叫做裴蜀定理。 思想：不断求较小数与两数余数的最大公约数，实际上是大数不断地减去小数，最后保留的数就是最大公约数 Python实现 '''普通计算''' m = int(input('please input a number:')) n = int(input('please input a number:')) max_n, min_n = max(m, n), min(m, n) r = max_n % min_n while r != 0: max_n = min_n min_n = r r = max_n % min_n print('最大公约数：',min_n) '''利用递归''' def highcf(m, n): m, n = max(m, n), min(m, n) r = m % n if r == 0: return n else: return highcf(n, r) # 单独写highcf(n, r)可以计算出结果，但是没有返回值 '''直接使用math.gcd()''' ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:1:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"2 质数判断 思想：除以2一直到平方根，都除不尽就是质数 import math # 用户输入数字 num = int(input(\"请输入一个数字: \")) if num \u003e 1: # 质数大于 1 square_num = math.floor( num ** 0.5 ) # 找到其平方根（ √ ），减少算法时间 for i in range(2, (square_num+1)): #将平凡根加1是为了能取到平方根那个值 if (num % i) == 0: print(num, \"是合数\") print(i, \"乘于\", num // i, \"是\", num) break else: print(num, \"是质数\") else: # 如果输入的数字小于或等于 1，不是质数 print(num, \"既不是质数，也不是合数\") ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:2:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"3 范围内素数计算 思想：在范围内迭代进行质数判断 def get_prime_number(lower, bigger): for num in range(lower, bigger+1): if num \u003e 1: sqrt = int(num ** 0.5) for i in range(2, sqrt+1): if num % i == 0: break else: yield num else: return lower = int(input('please input a lower number:')) bigger = int(input('please input a bigger number:')) lst = [i for i in get_prime_number(lower, bigger)] print(lst) '''骚气的filter一行语法糖''' list(filter(lambda x:len(list(filter(lambda y:x%y==0,range(2,int(x**0.5)+1))))==0,range(100,150))) #100-150之内的质数 ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:3:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"4 实现斐波那契数列 思想：迭代和递归 '''递归''' def fab(n): if n == 1: return 0 if n == 2: return 1 else: return fab(n-1)+fab(n-2) list(map(fab,range(1, 10))) \u003e\u003e\u003e[0, 1, 1, 2, 3, 5, 8, 13, 21] '''迭代''' def fab(n): arr = [0,1] a, b = 0, 1 while a \u003c n: a, b = b, a+b arr.append(a) return arr fab(10) \u003e\u003e\u003e[0, 1, 1, 1, 2, 3, 5, 8, 13] ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:4:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"5 最小公倍数 思想： 两个数的最小公倍数等于两数乘积除以最大公约数 先看大数是否能整除小数，不能的话，就是大数的整倍数 \"\"\"两个数的最小公倍数等于两数乘积除以最大公约数\"\"\" def lcm(b,s): m = b*s while (b!=0) and (s!=0): b, s = s, b%s return m//b print(lcm(b,s)) print(lcm(12,8)) \u003e\u003e\u003e24 \"\"\"先看大数是否能整除小数，不能的话，就是大数的整倍数\"\"\" def lcm(a, b): #a\u003eb count = 2 if a%b == 0: return a else: while a*count % b != 0: count += 1 return a*count print(lcm(12, 8)) ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:5:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"6 约瑟夫环问题 30 个人在一条船上，超载，需要 15 人下船。于是人们排成一队，排队的位置即为他们的编号。 报数，从 1 开始，数到 9 的人下船，然后下一个从1开始。如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？ 思想：把不相关的元素挪到列表尾部，每挪8个元素后，就把下一个元素剔除掉 def josephus(nums, step, stay): '''nums:总人数; step:摇号下船; stay:留在船上的人数''' lst = list(range(1, nums+1)) drop = [] while len(lst) \u003e stay: i = 1 while i \u003c step: lst.append(lst.pop(0)) i += 1 drop.append(lst.pop(0)) return drop josephus(30, 9, 28) \u003e\u003e\u003e[9, 18, 27, 6, 16, 26, 7, 19, 30, 12, 24, 8, 22, 5, 23] ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:6:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"7 五人分鱼问题 A、B、C、D、E 五人在某天夜里合伙去捕鱼，到第二天凌晨时都疲惫不堪，于是各自找地方睡觉。日上三杆，A 第一个醒来，他将鱼分为五份，把多余的一条鱼扔掉，拿走自己的一份。B 第二个醒来，也将鱼分为五份，把多余的一条鱼扔掉拿走自己的一份。 C、D、E 依次醒来，也按同样的方法拿鱼。问他们台伙至少捕了多少条鱼？ 思想：暴力增加鱼的个数，保证连续五次满足分鱼条件 def get_fish(): fish = 1 while True: total = fish #不能直接操作fish，导致死循环，要用total变量代替 for _ in range(5): if (total-1) % 5 == 0: total = (total-1)//5*4 else: break else: #for else 结构，for循环必须完全遍历完成后才会执行else语句，保证五次分鱼 return fish fish += 1 get_fish() ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:7:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"8 两变量交换 在不采用第三变量的情况下，交换两个变量的值 思想： 采用加减法 位运算（相同的数异或为0，与0异或为本身） a = a + b; b = a - b; a = a - b; ------------ x = x ^ y // （1） y = x ^ y // （2） x = x ^ y // （3） ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:8:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"}]