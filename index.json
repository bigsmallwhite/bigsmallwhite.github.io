[{"categories":["学习"],"content":"Linux-grep命令学习……","date":"2020-09-01","objectID":"/linux-grep/","tags":["Linux"],"title":"Linux-grep命令","uri":"/linux-grep/"},{"categories":["学习"],"content":" Linux grep 命令用于查找文件里符合条件的字符串。 grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。 语法 grep [-abcEFGhHilLnqrsvVwxy][-A\u003c显示列数\u003e][-B\u003c显示列数\u003e][-C\u003c显示列数\u003e][-d\u003c进行动作\u003e][-e\u003c范本样式\u003e][-f\u003c范本文件\u003e][--help][范本样式][文件或目录...] 参数 -a 或 --text : 不要忽略二进制的数据。 -A \u003c显示行数\u003e 或 --after-context=\u003c 显示行数 \u003e : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B \u003c显示行数\u003e 或 --before-context=\u003c 显示行数 \u003e : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c 或 --count : 计算符合样式的列数。 -C \u003c显示行数\u003e 或 --context=\u003c 显示行数 \u003e 或 -\u003c 显示行数 \u003e : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d \u003c动作\u003e 或 --directories=\u003c 动作 \u003e : 当指定要查找的是目录而非文件时，必须使用这项参数，否则 grep 指令将回报信息并停止动作。 -e \u003c范本样式\u003e 或 --regexp=\u003c 范本样式 \u003e : 指定字符串做为查找文件内容的样式。 -E 或 --extended-regexp : 将样式为延伸的正则表达式来使用。 -f \u003c规则文件\u003e 或 --file=\u003c 规则文件 \u003e : 指定规则文件，其内容含有一个或多个规则样式，让 grep 查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 --fixed-regexp : 将样式视为固定字符串的列表。 -G 或 --basic-regexp : 将样式视为普通的表示法来使用。 -h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 --ignore-case : 忽略字符大小写的差别。 -l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。 -L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。 -n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 --only-matching : 只显示匹配 PATTERN 部分。 -q 或 --quiet 或 --silent : 不显示任何信息。 -r 或 --recursive : 此参数的效果和指定-d recurse参数相同。 -s 或 --no-messages : 不显示错误信息。 -v 或 --revert-match : 显示不包含匹配文本的所有行（反向查找）。 -V 或 --version : 显示版本信息。 -w 或 --word-regexp : 只显示全字符合的列。 -x --line-regexp : 只显示全列符合的列。 -y : 此参数的效果和指定-i参数相同。 实例 1、在当前目录中，查找后缀有 .txt 字样的文件中包含 hello 字符串的文件，并打印出该字符串的行： grep -n hello *.txt # -n显示行号 结果如下所示： 2、以递归的方式查找符合条件的文件。例如，查找指定目录 /etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串update的文件，并打印出该字符串所在行的内容，使用的命令为： grep -r update /etc/acpi 3、反向查找。前面各个例子是查找并打印出符合条件的行，通过-v参数可以打印出不符合条件行的内容。 查找文件名中包含.txt 的文件中不包含 hello 的行，此时，使用的命令为： grep -v hello *.txt 结果如下所示： 4、大文件查找。系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行) 解决： grep -n '2019-10-24 00:01:11' *.log grep对比find 从文件内容查找匹配指定字符串的行： $ grep \"被查找的字符串\" 文件名 在当前目录里第一级文件夹中寻找包含指定字符串的 .in 文件 grep \"thermcontact\" /.in 从文件内容查找与正则表达式匹配的行： $ grep –e \"正则表达式\" 文件名 查找时不区分大小写： $ grep –i \"被查找的字符串\" 文件名 查找匹配的行数： $ grep -c \"被查找的字符串\" 文件名 从文件内容查找不匹配指定字符串的行： $ grep –v \"被查找的字符串\" 文件名 从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 \"ERROR\" 的行： $ find / -type f -name \"*.log\" | xargs grep \"ERROR\" 从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 \"thermcontact\" 的行： find . -name \"*.in\" | xargs grep \"thermcontact\" 注：xargs是把左侧的标准输出转化为右侧的格式化参数，如果没有xargs的作用，那么那么上述两行语句的作用就是在一堆文件名中查找匹配的文件名，有了xargs，就是在一堆文件中查找匹配的内容行。 ","date":"2020-09-01","objectID":"/linux-grep/:0:0","tags":["Linux"],"title":"Linux-grep命令","uri":"/linux-grep/"},{"categories":["学习"],"content":"Linux如何查看系统进程……","date":"2020-08-31","objectID":"/linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/","tags":["Linux"],"title":"Linux查看系统进程","uri":"/linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/"},{"categories":["学习"],"content":" 进程是在 CPU 及内存中运行的程序代码，而每个进程可以创建一个或多个进程（父子进程） 在linux中可能不明显，但是windows系统中的任务管理器大家应该都很熟悉： 在linux中查看系统进程的命令有不少，以下是一些常用命令。 ps命令 ps (process status) 命令是 Linux 下最常用的进程查看工具。使用该命令可以确定哪些进程正在运行和运行的状态、进程是否结束、有没有僵尸进程、哪些进程占用了过多的资源等等。 注意：ps 命令工具显示的是进程的瞬间状态（相当于截图），并不是动态连续显示。 主要的参数：[aux] a：显示当前终端下的所有进程信息，包括其他用户的进程。 u：使用以用户为主的格式输出进程信息。 x：显示当前用户在所有终端下的进程。 字段解释 USER：启动该进程的用户账号名称 PID：该进程的 唯一ID 号 %CPU：CPU 占用的百分比 %MEM：内存占用的百分比 VSZ：占用虚拟内存（swap 空间）的大小 RSS：占用常驻内存（物理内存）的大小 TTY 或 TT：表示该进程在哪个终端上运行。不是从终端启动的进程或与终端机无关的进程则显示为 ？ STAT：显示了进程当前的状态。如以下： D 不可中断的休眠。通常是 IO。 R 运行。正在运行或者在运行队列中等待。 S 休眠。在等待某个事件，信号。 T 停止。进程接收到信息 SIGSTOP，SIGSTP，SIGTIN，SIGTOU 信号。 X 死掉的进程，不应该出现。 Z 僵死进程。对发现处于僵死状态的进程应予以手动终止。 通常还会跟随如下字母表示更详细的状态： \u003c 高优先级 N 低优先级 L 有 pages 在内存中 locked。用于实时或者自定义 IO。 s 进程领导者，其有子进程。 l 多线程 +位于前台进程组 START：启动该进程的时间 TIME：该进程占用 CPU 时间 COMMAND：启动该进程的命令的名称 总结：ps aux 是以简单列表的形式显示出进程信息。 此外，还有另外一种方式：-[elf] -e：显示系统内的所有进程信息。 -l：使用长（long）格式显示进程信息。 -f：使用完整的（full）格式显示进程信息。 PPID 为父进程的 PID 两种方式的对比 ps -ef 是用标准的格式显示进程，显示的项目有：UID, PID, PPID, C, STIME, TTY, TIME, CMD 字段 ps aux 是用 BSD 的格式来显示进程，显示的项目有：USER, PID, % CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME, COMMAND 字段 所示： 如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux 如果想查看进程的父进程 ID 和完整的 COMMAND 命令，可以使用 -ef top命令 以全屏交互式的界面显示进程排名，及时跟踪包括 CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次，其作用基本类似于 Windows 系统中的任务管理器。 字段解释 Tasks（系统任务）信息： total：总进程数； running：正在运行的进程数； sleeping：休眠的进程数； stopped：中止的进程数； zombie：僵死无响应的进程数。 CPU 信息： us：用户占用； sy：内核占用； ni：优先级调度占用； id：空闲 CPU； wa：I/O 等待占用； hi：硬件中断占用； si：软件中断占用； st：虚拟化占用。 Mem（内存）信息： total：总内存空间； used：已用内存； free：空闲内存； buffers：缓存区域。 Swap（交换空间）信息： total：总交换空间； used：已用交换空间； free：空闲交换空间； cached：缓存空间。 了解空闲的 CPU 百分比，主要看 % id 部分。 htop命令 htop 与 top 很类似，但是 htop 是交互式的文本模式的进程查看器。它通过文字图形化地显示每一个进程的 CPU 和内存使用量、swap 使用量。使用上下光标键选择进程，F7 和 F8 改变优先级，F9 杀死进程。 pstree命令 linux 中，每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。 可用参数： -a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示； -c：不使用精简标示法； -G：使用 VT100 终端机的列绘图字符； -h：列出树状图时，特别标明现在执行的程序； -H \u003c程序识别码\u003e：此参数的效果和指定 “-h” 参数类似，但特别标明指定的程序； -l：采用长列格式显示树状图； -n：用程序识别码排序。预设是以程序名称来排序； -p：显示程序识别码； -u：显示用户名称； 优化使用 在实际的使用过程中，单纯上述命令的返回结果真的是让人看的眼都花了…… 其实我们根本不需要那么详细或者那么全面的进程信息，可能我们只在意某个进程的某个信息…… 1-grep 使用管道符|配合grep字符串匹配，定位到含有特定字符的进程 ps aux | grep ubuntu 可通过kill -s 9 [pid]强制杀死进程。 2-pgrep pgrep 的 p 表明了这个命令是专门用于进程查询的 grep，pgrep 是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行。 参数： --help 显示帮助文档 --version 显示命令版本 -d delimiter 设置用于分隔输出中每个进程ID的字符串(默认为换行符)。(仅限于pgrep) -f 查找完成的文件名 -g pgrp 只匹配列出的进程组ID中的进程。进程组0被转换为pgrep或pkill自己的进程组。 -G gid 只匹配实际组ID列出的进程。可以使用数值或符号值。 -l 列出进程的名字和id -n 选择最近执行的进程 -o 选择最早的进程 -P ppid 选择父pid匹配的进程 -s sid 只匹配进程会话ID列出的进程。会话ID 0被转换为pgrep或pkill自己的会话ID。 -t term 查找符合终端号的进程 -u euid 只匹配其有效用户ID列出的进程。 -U uid 只匹配实际用户ID列出的进程。可以使用数值或符号值。 -v 查找不符合条件的进程 -x 只匹配其名称(如果-f指定了命令行)与模式完全匹配的进程。 如列出进程的名字和 id pgrep -l bash 3-pidof 直接查询某个进程的pid，但是需要知道进程的全名 ","date":"2020-08-31","objectID":"/linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/:0:0","tags":["Linux"],"title":"Linux查看系统进程","uri":"/linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/"},{"categories":["学习"],"content":"Linux中的\u0026\u0026和\u0026，|和||命令……","date":"2020-08-30","objectID":"/linux%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/","tags":["Linux"],"title":"Linux中的\u0026\u0026和\u0026，|和||","uri":"/linux%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"},{"categories":["学习"],"content":"\u0026 \u0026表示任务在后台执行 默认情况下，进程是前台进程，这时就把 Shell 给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个 \u0026 实现这个目的 比如我们要把一个文件复制到另一个目录中： cp -R original/dir/ backup/dir/ 如果复制的文件太多太大，直接会导致当前终端卡住。 可以在命令的末尾加上一个 \u0026 号，将这个任务放到后台去执行： cp -R original/dir/ backup/dir/ \u0026 任务被放到后台执行之后，就可以继续在同一个终端上操作了，甚至关闭终端也不影响这个任务的正常执行。需要注意的是，如果要求这个任务输出内容到标准输出中（例如 echo 或 ls），即使使用了 \u0026，也会等待这些输出任务在前台运行完毕。 当使用 \u0026 将一个进程放置到后台运行的时候，Bash 会提示这个进程的进程 ID 比如我们后台执行top命令：top \u0026 返回了top进程的id--\u003e9398，如果杀掉该进程，可以发现top stopped。 \u0026\u0026 命令之间使用 \u0026\u0026 连接，实现逻辑与的功能。 在执行某个命令时，有时需要依赖前面的命令是否执行成功。\u0026\u0026表示前一条命令执行成功时，才执行后一条命令 。 格式：command1 \u0026\u0026 command2 例如，当把文件 first.txt 复制一份为 first.bak.txt 成功，然后显示副本 first.bak.txt cp first.txt first.bak.txt \u0026\u0026 cat first.bak.txt | | 表示管道，上一条命令的输出，作为下一条命令参数。 Linux 所提供的管道符 | 将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。 如： echo 'yes' | wc -l # 显示输入的行数 再比如获取特定的进程信息： ps -aux | grep root # 显示含root的进程 || 命令之间使用 || 连接，实现逻辑或的功能，表示上一条命令执行失败后，才执行下一条命令。 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。 –直到返回真的地方停止执行。 如 cat errorfile || echo \"fail\" # cat一个错误的文件，然后就会打印fail ","date":"2020-08-30","objectID":"/linux%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/:0:0","tags":["Linux"],"title":"Linux中的\u0026\u0026和\u0026，|和||","uri":"/linux%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"},{"categories":["学习"],"content":"Linux文件内容查看常用命令……","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":" 学习linux，必然少不了经常对文件内容的查看，以下是一些常用的查看命令。 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 man [命令]来查看各个命令的使用文档，如 ：man cat。 ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:0","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"cat（第一行显示） 由第一行开始显示文件内容 cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同，效果类似nl命令； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 检看 /etc/issue 这个文件的内容： cat /etc/issue Ubuntu 18.04.4 LTS \\n \\l # 多出一个空行 ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:1","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"tac（最后一行显示） tac与cat命令刚好相反，文件内容从最后一行开始显示（倒序显示），如： tac /etc/issue # 空行在前面 Ubuntu 18.04.4 LTS \\n \\l ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:2","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"nl（显示行号） 显示行号 nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:3","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"more（翻页） 一页一页翻动 more /etc/man_db.config # # Generated automatically from man.conf.in by the # configure script. # # man.conf from man-1.6d ....(中间省略).... --More--(28%) \u003c== 光标在这里等待你的命令 在 more 这个程序的运行过程中，有以下命令可执行： 空白键 (space)：代表向下翻一页； Enter：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻字串这个关键字； :f：立刻显示出档名以及目前显示的行数； q：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b：代表往回翻页，只对文件有用。 ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:4","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"less（翻页） 一页一页翻动，以下实例输出/etc/man.config文件的内容： less /etc/man.config # # Generated automatically from man.conf.in by the # configure script. # # man.conf from man-1.6d ....(中间省略).... : \u003c== 这里可以等待你输入命令！ 在less这个程序的运行过程中，有以下命令可执行： 空白键：向下翻动一页； [pagedown]：向下翻动一页； [pageup]：向上翻动一页； /字串：向下搜寻字串的功能； ?字串：向上搜寻字串的功能； n：重复前一个搜寻 (与 / 或 ? 有关) N：反向的重复前一个搜寻 (与 / 或 ? 有关) q：离开 less 这个程序； ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:5","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"head（显示头几行） 取出文件前面几行 head [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 head /etc/man.config 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： head -n 20 /etc/man.config ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:6","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"tail（显示尾几行） 取出文件后面几行 tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 tail /etc/man.config # 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样： tail -n 20 /etc/man.config ","date":"2020-08-29","objectID":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/:0:7","tags":["Linux"],"title":"Linux文件内容查看","uri":"/linux%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B/"},{"categories":["学习"],"content":"Linux文件和目录管理常用命令……","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"对于文件和目录的管理，可视化界面操作只需要鼠标点点点即可，例如windows系统的文件资源管理器，在linux系统中，虽然也有一些图形界面，不过熟悉命令操作后，速度也不慢。 ls: 列出目录及文件名 cd：切换目录 pwd：显示目前的路径 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:0","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"ls (列出目录) 在Linux系统当中， ls 命令可能是最常被运行的。 选项与参数（可以搭配使用）： -a ：全部文件，连同隐藏文件( 开头为.的文件) 一起列出来(常用) -d ：仅列出目录本身，而不列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据(常用) 将home目录下的所有文件列出来(含属性与隐藏文件)：ls -al ~ 显示颜色 ls --color可以显示不问类型文件的颜色，永久显示的话， 1、在home目录下 cd ~ 2、打开.bashrc文件，没有的话，创建touch .bashrc，再打开 vim .bashrc 3、输入i，加入alias ls='ls --color'，按esc，输入:wq保存退出 4、然后重新加载该文件即可 source ./.bashrc 重启颜色失效解决办法 重启后颜色显示失效，说明没有自动加载.bashrc文件，先打开.bash_profile文件：vim ~/.bash_profile 添加如下代码即可 if test -f .bashrc ; then # 测试.bashrc存在且为普通文件则为真 source .bashrc fi ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:1","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"cd (切换目录) cd是Change Directory的缩写，这是用来变换工作目录的命令。 使用 mkdir 命令创建 runoob 目录 mkdir runoob 使用绝对路径切换到 runoob 目录 cd /root/runoob/ 使用相对路径切换到 runoob 目录 cd ./runoob/ 进入上级目录 cd .. 进入当前用户主目录 cd ~ 进入根目录 cd / 进入上两级目录 cd ../.. 进入当前目录 cd . 进入目录/etc/docker cd /etc/docker ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:2","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"pwd (显示目前所在的目录) pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 pwd [-P] 选项与参数： -P ：显示出确实的路径，而非使用连结 (link) 路径。 实例：单纯显示出目前的工作目录： pwd /root \u003c== 显示出目录啦～ 实例显示出实际的工作目录，而非连结档本身的目录名而已。 cd /var/mail \u003c==注意，/var/mail是一个连结档 pwd /var/mail \u003c==列出目前的工作目录 pwd -P /var/spool/mail \u003c==怎么回事？有没有加 -P 差很多～ ls -ld /var/mail lrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -\u003e spool/mail # 因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径 ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:3","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"mkdir (创建新目录) 想要创建新的目录的话，使用mkdir (make directory)即可。 mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限 -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 实例：请到/tmp底下尝试创建数个新目录看看： cd /tmp mkdir test \u003c==创建一名为 test 的新目录 mkdir test1/test2/test3/test4 mkdir: cannot create directory `test1/test2/test3/test4': No such file or directory \u003c== 没办法直接创建此目录啊！ mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！ 创建权限为 rwx--x--x 的目录 mkdir -m 711 test2 ls -l drwxr-xr-x 3 root root 4096 Jul 18 12:50 test drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx--x--x 的权限。 ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:4","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"rmdir (删除空的目录) 语法： rmdir [-p] 目录名称 选项与参数： -p ：连同上一级『空的』目录也一起删除 删除 runoob 目录 rmdir runoob/ 将 mkdir 实例中创建的目录(/tmp 底下)删除掉！ ls -l \u003c==看看有多少目录存在？ drwxr-xr-x 3 root root 4096 Jul 18 12:50 test drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 drwx--x--x 2 root root 4096 Jul 18 12:54 test2 rmdir test \u003c==可直接删除掉，没问题 rmdir test1 \u003c==因为尚有内容，所以无法删除！ rmdir: `test1': Directory not empty rmdir -p test1/test2/test3/test4 ls -l \u003c==您看看，底下的输出中test与test1不见了！ drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。 不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。 ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:5","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"cp (复制文件或目录) cp 即拷贝文件和目录。 语法: cp [-adfilprsu] 来源档(source) 目标档(destination) cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr ，参数 pdr 分别为：保留权限，bai 复制软链接本身，递归复制；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc cp ~/.bashrc /tmp/bashrc cp -i ~/.bashrc /tmp/bashrc cp: overwrite `/tmp/bashrc'? n \u003c==n不覆盖，y为覆盖 ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:6","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"rm (移除文件或目录) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 将刚刚在 cp 的实例中创建的 bashrc 删除掉！ rm -i bashrc rm: remove regular file `bashrc'? y 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！ ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:7","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"mv (移动文件与目录，或修改名称) 语法： mv [-fiu] source destination mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 复制一文件，创建一目录，将文件移动到目录中 cd /tmp cp ~/.bashrc bashrc mkdir mvtest mv bashrc mvtest 修改目录名：将刚刚的目录名称更名为 mvtest2 mv mvtest mvtest2 ","date":"2020-08-28","objectID":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/:0:8","tags":["Linux"],"title":"Linux文件和目录管理","uri":"/linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"},{"categories":["学习"],"content":"Linux文件属性命令……","date":"2020-08-27","objectID":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/","tags":["Linux"],"title":"Linux文件属性命令","uri":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/"},{"categories":["学习"],"content":"windows系统 文件属性，在windows系统中，我们很少考虑文件的属性问题，默认即可。 当然需要修改的话，也很简单，右键文件--\u003e属性，如下图所示（以文件为例）。 一般文件的属性有三种，包括常规、安全、详细信息，文件夹是常规、安全、共享、自定义。 在可修改的地方点击编辑即可，比如组或用户名、每个组或用户名对应的控制权限。 ","date":"2020-08-27","objectID":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/:0:1","tags":["Linux"],"title":"Linux文件属性命令","uri":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/"},{"categories":["学习"],"content":"linux系统 在linux系统中，文件的属性就显得稍微重要一点，可直接使用命令修改。 ls –l命令来显示一个文件的属性以及文件所属的用户和组 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为d则是目录 当为-则是文件 若是l则表示为链接文档(link file) 若是b则表示为装置文件里面的可供储存的接口设备(可随机存取装置) 若是c则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置) 接下来的字符中，以三个为一组，且均为rwx 的三个参数的组合。其中， r代表可读(read) w代表可写(write) x代表可执行(execute) 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号-，每个文件的属性由左边第一部分的10个字符来确定，如下图: 从左至右用0-9这些数字来表示： 第0位确定文件类型； 第1-3位确定属主（该文件的所有者）拥有该文件的权限； 第4-6位确定属组（所有者的同组用户）拥有该文件的权限； 第7-9位确定其他用户拥有该文件的权限。 其中： 第1, 4, 7位表示读权限，如果用r字符表示，则有读权限，如果用-字符表示，则没有读权限； 第2, 5, 8位表示写权限，如果用w字符表示，则有写权限，如果用-字符表示没有写权限； 第3, 6, 9位表示可执行权限，如果用x字符表示，则有执行权限，如果用-字符表示，则没有执行权限。 ","date":"2020-08-27","objectID":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/:0:2","tags":["Linux"],"title":"Linux文件属性命令","uri":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/"},{"categories":["学习"],"content":"linux更改文件属性 1、chgrp：更改文件属组 语法： chgrp [-R] 属组名 文件名 参数选项 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主 语法： chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： [root@www ~] cd ~ [root@www ~]# chown bin install.log [root@www ~]# ls -l -rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log 将install.log的拥有者与群组改回为root： [root@www ~]# chown root:root install.log [root@www ~]# ls -l -rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log 3、chmod：更改文件9个属性 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 文件的权限字符为：-rwxrwxrwx， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： 字符 数值 r 4 w 2 x 1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： -rwxrwx---分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= --- = 0+0+0 = 0 所以等一下我们设定权限的变更时，该文件的权限数字就是770，变更权限的指令chmod的语法是这样的： chmod [-R] xyz 文件或目录 选项与参数 xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归的持续变更，即连同次目录下的所有文件都会变更 举例来说，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下： [root@www ~]# ls -al .bashrc -rw-r--r-- 1 root root 395 Jul 4 11:45 .bashrc [root@www ~]# chmod 777 .bashrc [root@www ~]# ls -al .bashrc -rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc 那如果要将权限变成 -rwxr-xr-- 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。 4、chmod：符号类型改变文件权限 还有一个改变权限的方法，基本上就九个权限分别是：user、group、others。 可以使用 u, g, o 来代表三种身份的权限！ 此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看： chmod u g o a +(加入) -(除去) =(设定) r w x 文件或目录 将文件权限设置为 -rwxr-xr-- ，可以使用 chmod u=rwx,g=rx,o=r 文件名 来设定: touch test1 // 创建 test1 文件 ls -al test1 // 查看 test1 默认权限 -rw-r--r-- 1 root root 0 Nov 15 10:32 test1 chmod u=rwx,g=rx,o=r test1 // 修改 test1 权限 ls -al test1 -rwxr-xr-- 1 root root 0 Nov 15 10:32 test1 去掉全部人的可执行权限： chmod a-x test1 // a为全部，-为减去，x为可执行 ls -al test1 -rw-r--r-- 1 root root 0 Nov 15 10:32 test1 ","date":"2020-08-27","objectID":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/:0:3","tags":["Linux"],"title":"Linux文件属性命令","uri":"/linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%91%BD%E4%BB%A4/"},{"categories":["学习"],"content":"Python实现树结构……","date":"2020-08-26","objectID":"/%E6%A0%91/","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["学习"],"content":"定义 如上图所示，树是一个有n个有限节点组成一个具有层次关系的集合，每个节点有0个或者多个子节点，没有父节点的节点称为根节点。 树的种类比较多，有二叉树，红黑树，AVL树，B树，哈夫曼树，字典树等等。 树的这么多种类中，我们最常见的应该是二叉树了，下面我们来看看如何实现二叉树的一些基本功能。 ","date":"2020-08-26","objectID":"/%E6%A0%91/:0:1","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["学习"],"content":"基本概念 结点的度：一个结点含有的子结点的个数称为该结点的度； 叶结点或终端结点：度为0的结点称为叶结点； 非终端结点或分支结点：度不为0的结点； 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点； 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点； 兄弟结点：具有相同父结点的结点互称为兄弟结点； 树的度：一棵树中，最大的结点的度称为树的度； 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推； 树的高度或深度：树中结点的最大层次； 堂兄弟结点：双亲在同一层的结点互为堂兄弟； 结点的祖先：从根到该结点所经分支上的所有结点； 子孙：以某结点为根的子树中任一结点都称为该结点的子孙。 森林：由m（m\u003e=0）棵互不相交的树的集合称为森林； 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树; 有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树； 二叉树：每个节点最多含有两个子树的树称为二叉树； 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 哈夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树； ","date":"2020-08-26","objectID":"/%E6%A0%91/:0:2","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["学习"],"content":"构造节点 一个完整的树节点包括当前节点值、左节点指针和右节点指针 class Node(object): \"\"\"构造树节点\"\"\" def __init__(self, item): # 节点的值 self.element = item # 左子节点 self.lchild = None # 右子节点 self.rchild = None ","date":"2020-08-26","objectID":"/%E6%A0%91/:0:3","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["学习"],"content":"构造树 class Tree(object): \"\"\"二叉树\"\"\" def __init__(self, root = None): self.root = root ","date":"2020-08-26","objectID":"/%E6%A0%91/:0:4","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["学习"],"content":"添加节点 添加节点是按照顺序（一层一层）添加的，如下图所示的二叉树，依次添加的节点为[A, B, C, D, E, F]，想要添加元素，就必须先遍历节点，所以需要一层层遍历节点，判断节点的左右子节点是否为空。 具体的添加过程： 如果树为空，直接添加在根节点就行，如A节点 如果不为空，需要通过队列遍历节点，逐个判断节点的左右子节点是否为空 如现在树不为空，已经有了A节点[A] 弹出A节点，判断左节点是否为空，是，添加B；否，B入队列，同理判断右节点 依次类推，每次循环弹出一个节点，先后判断左右节点是否为空，为空则加入待添加元素，不为空则如队列 具体的代码实现如下： def add(self, item): node = Node(item) # 判断树是否为空树 if self.root is None: self.root = node return queue = [self.root] while queue: # 弹出元素 cur_node = queue.pop(0) # 判断左子节点 if cur_node.lchild is None: cur_node.lchild = node return else: queue.append(cur_node.lchild) # 判断右子节点 if cur_node.rchild is None: cur_node.rchild = node return else: queue.append(cur_node.rchild) ","date":"2020-08-26","objectID":"/%E6%A0%91/:0:5","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["学习"],"content":"遍历节点 遍历节点就是访问树的各个节点，一般分为两种，广度优先（层次遍历）和深度优先。 广度优先遍历 访问顺序是：先访问上一层，在访问下一层，一层一层的往下访问 所以上图前序遍历的结果是：A→B→C→D→E→F 访问顺序如下 具体代码如下： def bread_travel(self): \"\"\"广度优先遍历/层次遍历\"\"\" queue = [self.root] while queue: cur_node = queue.pop(0) print(cur_node.element) if cur_node.lchild: queue.append(cur_node.lchild) if cur_node.rchild: queue.append(cur_node.rchild) 深度优先遍历 深度优先遍历一般分为先序、中序、后序三种，所谓的先、中、后是指根节点的访问顺序，而且左节点永远在右节点前。 先序遍历 访问顺序是：根节点→左子树→右子树 所以上图前序遍历的结果是：A→B→D→E→C→F 访问顺序如下 具体的代码如下： 递归方式 def pre_deep_travel(self, node): \"\"\"先序遍历\"\"\" if node is None: return print(node.element, end=' ') self.pre_deep_travel(node.lchild) self.pre_deep_travel(node.rchild) 非递归方式 def pre_deep_travel1(self, node): if node is None: return stack = [node] while stack: node = stack.pop() print(node.element, end= ' ') if node.right: stack.append(node.right) if node.left: stack.append(node.left) 中序遍历 访问顺序是：左子树→根节点→右子树 所以上图前序遍历的结果是：D→B→E→A→F→C 访问顺序如下 具体的代码如下： 递归方式 def in_deep_travel(self, node): \"\"\"中序遍历\"\"\" if node is None: return self.in_deep_travel(node.lchild) print(node.element, end=' ') self.in_deep_travel(node.rchild) 非递归方式 def in_deep_travel1(self, node): stack = [] while node or stack: # 先添加所有左节点 while node is not None: stack.append(node) node = node.left if stack: node = stack.pop() print(node.element, end=' ') # 再添加右节点 node = node.right 后续遍历 访问顺序是：左子树→右子树→根节点 所以上图前序遍历的结果是：D→E→B→F→C→A 访问顺序如下 具体大代码如下： 递归方式 def post_deep_travel(self, node): \"\"\"后序遍历\"\"\" if node is None: return self.post_deep_travel(node.lchild) self.post_deep_travel(node.rchild) print(node.element, end=' ') 非递归方式 双栈法，很巧妙的方法，每个节点入第一个栈的顺序是[根, 左, 右]，其实就是反过来的先序遍历，在每次循环时，弹出第一个栈的栈顶元素，并入第二个栈，那么每个节点在第二个栈的顺序是[根, 右, 左]。本质就是把反过来的先序遍历再反一遍，就是后续遍历。 def post_deep_travel1(self, node): if node is None: return stack1 = [node] stack2 = [] while stack1: node = stack1.pop() stack2.append(node) if node.left: stack1.append(node.left) if node.right: stack1.append(node.right) while stack2: node = stack2.pop() print(node.element, end=' ') ","date":"2020-08-26","objectID":"/%E6%A0%91/:0:6","tags":["Python","数据结构"],"title":"数据结构--树","uri":"/%E6%A0%91/"},{"categories":["logs"],"content":"特别恭喜博客中另一位大写的人成功迈进半只脚，预祝顺利上岸……","date":"2020-08-25","objectID":"/2020-8-25-%E8%BF%88%E8%BF%9B%E4%B8%80%E5%8F%AA%E8%84%9A/","tags":[],"title":"好运来来","uri":"/2020-8-25-%E8%BF%88%E8%BF%9B%E4%B8%80%E5%8F%AA%E8%84%9A/"},{"categories":["logs"],"content":"今天农历7月7，一个让年轻人“聚类”的日子 有的成双入对👨‍👧 ，有的形影孤单👷‍♂️ 这里不酸，我也是成对儿的🙌 一起逛街、吃饭…… 逛街是开心的，但是买衣服意见不和；吃饭是开心的，但是点菜意见不和 下一次，剪刀石头布 正常的一天，难忘的经历，回来的时候仍然开开心心的 以后的每个七夕都有彼此😘@Y PS：预祝顺利上岸！！！ ","date":"2020-08-25","objectID":"/2020-8-25-%E8%BF%88%E8%BF%9B%E4%B8%80%E5%8F%AA%E8%84%9A/:0:0","tags":[],"title":"好运来来","uri":"/2020-8-25-%E8%BF%88%E8%BF%9B%E4%B8%80%E5%8F%AA%E8%84%9A/"},{"categories":["学习"],"content":"只能用递归实现栈的逆序……","date":"2020-08-24","objectID":"/%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F%E6%A0%88/","tags":["Python","算法"],"title":"实现逆序栈","uri":"/%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F%E6%A0%88/"},{"categories":["学习"],"content":"偶然间看到一道题，不能使用其他的数据结构，只能用递归，把一个栈的元素反转。 假如一个空栈[],先后入栈元素3, 2, 1–\u003e [3, 2, 1], 只利用递归实现[3, 2, 1] --\u003e [1, 2, 3]。 解决该问题的核心思想是： 如何通过递归算法来弹出栈底元素，也就是实现一个popLast函数，只要获取了栈底的元素，然后递归的进行逆序就行 def reverseStack(stack): # 递归地把栈内元素取出来 if stack: temp = getLast(stack) reverseStack(stack) # 递归后，后取出的先入栈 stack.append(temp) return stack def popLast(stack): top = stack.pop() if not stack: return top else: # 递归的弹出元素 res = popLast(stack) # 把前两次递归弹出的元素按相同的顺序入栈 stack.append(top) return res if __name__ == '__main__': stack = [3, 2, 1] print(reverseStack(stack)) \u003e\u003e\u003e[1, 2, 3] ","date":"2020-08-24","objectID":"/%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F%E6%A0%88/:0:0","tags":["Python","算法"],"title":"实现逆序栈","uri":"/%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F%E6%A0%88/"},{"categories":["学习"],"content":"单调栈的理解和实现……","date":"2020-08-23","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["Python","算法"],"title":"单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["学习"],"content":"做完题后喜欢看看别人的思路，总能发现不一样的方法，让人直呼🤙🤙🤙 在用递归做完最大二叉树后，也是看到别人用单调栈的方法，发现很巧妙，想着深入学习一下~ 什么是单调栈 单调栈指的是：栈中存放的数据出栈应该是有序的 单调递增栈：栈中数据出栈的序列为单调递增序列(栈顶到栈底–\u003e递增) 单调递减栈：栈中数据出栈的序列为单调递减序列(栈顶到栈底–\u003e递减) 栈结构大家都很熟悉（先进后出），那单调栈到底有啥用呢？ 单调栈主要回答这样的几种问题: 比当前元素更大的下一个元素 比当前元素更大的前一个元素 比当前元素更小的下一个元素 比当前元素更小的前一个元素 废话不多说，还是直接用代码解释更简单明了…… 更大的下一个 def nextGreaterElement(self, nums): ''' res:'-1'代表没有大于当前元素的值，其他值代表大于当前值的下一个值，下同 ''' stack = list() res = [-1] * len(nums) for i, n in enumerate(nums): # 入栈元素只能比栈顶元素小，新元素大于栈顶，就要更新 while stack and nums[stack[-1]] \u003c n: # 这一步执行具体的操作，这里是记录下一个大的数 res[stack.pop()] = n stack.append(i) return res 更大的前一个 def preGreaterElement(self, nums): stack = list() res = [-1] * len(nums) for i, n in enumerate(nums): # 保证先进栈的元素大，如果来个更大的，就把前面小的全部pop掉，保证站内元素是紧密相连的有序序列 while stack and nums[stack[-1]] \u003c n: stack.pop() if stack: res[i] = nums[stack[-1]] stack.append(i) return res 更小的下一个 def nextSmallerElement(self, nums): stack = list() res = [-1] * len(nums) for i, n in enumerate(nums): # 入栈元素只能比栈顶元素大 while stack and nums[stack[-1]] \u003e n: # 这一步执行具体的操作，这里是记录下一个小的数 res[stack.pop()] = n stack.append(i) return res 更小的前一个 def preSmallerElement(self, nums): stack = list() res = [-1] * len(nums) for i, n in enumerate(nums): # 保证先进栈的元素小 while stack and nums[stack[-1]] \u003e n: stack.pop() if stack: res[i] = nums[stack[-1]] stack.append(i) return res 总结：单调栈就是维护一个栈内数据有序的栈，只要栈内元素不是单调的，就一个个把栈顶元素pop掉，直到新加入的元素和剩余的元素单调为止。在pop操作的同时，更新具体需求的操作就行。具体的实例有很多，可以查看上一篇文章最大二叉树的单调栈解法。 ","date":"2020-08-23","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:0","tags":["Python","算法"],"title":"单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["学习"],"content":"Python实现最大二叉树……","date":"2020-08-22","objectID":"/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["Python","leetcode"],"title":"最大二叉树","uri":"/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["学习"],"content":"这题其实用递归很简单，重点是单调栈的解法~ 信息 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。 示例： 输入： [3,2,1,6,0,5] 输出：返回下面这棵树的根节点： 6 / \\ 3 5 \\ / 2 0 \\ 1 方法 思路一：递归，思路不难 找到当前数组的最值，构建节点 节点的左子结点–\u003e找到当前数组（上一个节点的左侧）的最值，构建节点； 节点的右子结点–\u003e找到当前数组（上一个节点的右侧）的最值，构建节点。 思路二：单调栈，单调栈维护的是严格的单调数组，在本题中，通过递增栈（出栈顺序）构建树 stack = [] [] 3 --\u003e 3入栈[3] 2\u003c3 --\u003e 2入栈[3,2], 3.right = 2 1\u003c1 --\u003e 1入栈[3,2,1], 2.right = 1 6\u003e1 --\u003e 1出栈[3,2], 6.left = 1 6\u003e2 --\u003e 2出栈[3], 6.left = 2 6\u003e3 --\u003e 3出栈[], 6.left = 3 [] 6 --\u003e 6入栈[6] 0\u003c6 --\u003e 0入栈[6,0], 6.right = 0 5\u003e0 --\u003e 0出栈[6], 5.left = 0 5\u003c6 --\u003e 5入栈[6,5], 6.right = 5 return stack[0] 方法一代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 递归 def constructMaximumBinaryTree1(self, nums) -\u003e TreeNode: if len(nums) == 0: return max_num = max(nums) root = TreeNode(max_num) root.left = self.constructMaximumBinaryTree1(nums[:nums.index(max_num)]) root.right = self.constructMaximumBinaryTree1(nums[nums.index(max_num)+1:]) return root 方法二代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 单调栈 def constructMaximumBinaryTree2(self, nums) -\u003e TreeNode: stack = list() for n in nums: cur = TreeNode(n) # 当前节点大于栈顶元素，pop的仅次于当前节点的元素是当前元素的左子树根 while stack and stack[-1].val \u003c n: cur.left = stack.pop() # 新加入的加点一定小于栈顶元素，一定是栈顶元素的右子树根 if stack: stack[-1].right = cur stack.append(cur) # 最后的节点最大，为整棵树的根 return stack[0] ","date":"2020-08-22","objectID":"/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["Python","leetcode"],"title":"最大二叉树","uri":"/%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["学习"],"content":"Python实现两个二叉树的对称、合并、翻转……","date":"2020-08-21","objectID":"/%E5%AF%B9%E7%A7%B0%E5%90%88%E5%B9%B6%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":["Python","leetcode"],"title":"对称、合并、翻转二叉树二叉树","uri":"/%E5%AF%B9%E7%A7%B0%E5%90%88%E5%B9%B6%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["学习"],"content":"最近一直在练习二叉树的题🙃 ，再接再厉😂!!! 对称二叉树 信息 给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的。 1 / \\ 2 2 \\ \\ 3 3 方法 思路一：BFS迭代，层次遍历每一层，判断每一层的值是否是回文数 思路二：递归，如果左树的左孩子与右树的右孩子对称，左树的右孩子与右树的左孩子对称，那么这个左树和右树就对称：def 函数A（左树，右树）：左树节点值等于右树节点值 且 函数A（左树的左子树，右树的右子树）and 函数A（左树的右子树，右树的左子树）为真 才返回真 思路一代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isSymmetric1(self, root: TreeNode) -\u003e bool: if root is None: return True # 队列存储中间节点 queue = [root] while queue: # 存储每一层节点的值 result = [] length = len(queue) for i in range(length): node = queue.pop(0) # 如果节点为空，直接添加None，不再进队列 if not node: result.append(None) continue queue.append(node.left) queue.append(node.right) result.append(node.val) # 判断当前层是否对称 temp = result[::-1] if result != temp: return False return True 思路二代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isSymmetric2(self, root: TreeNode) -\u003e bool: def check(node1, node2): # 两个节点都为空，对称 if not node1 and not node2: return True # 有一个节点不为空，不对称 elif not node1 or not node2: return False # 节点的值不等，不对称 if node1.val != node2.val: return False return check(node1.left, node2.right) and check(node1.right, node2.left) return check(root, root) 合并二叉树 信息 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值， 否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 输入: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 输出: 合并后的树: 3 / \\ 4 5 / \\ \\ 5 4 7 注意: 合并必须从两个树的根节点开始。 方法 思路一：递归，不断合并两棵树对应节点的值，如果一个为空，就直接指向另一个节点 思路二：迭代，BFS，广度优先遍历 思路一代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 递归修改树结构 def mergeTrees1(self, t1: TreeNode, t2: TreeNode) -\u003e TreeNode: if not t1: return t2 if not t2: return t1 # 合并根节点 t1.val += t2.val # 迭代左子节点 t1.left = self.mergeTrees1(t1.left, t2.left) # 迭代右子节点 t1.right = self.mergeTrees1(t1.right, t2.right) return t1 #递归不修改树结构 def mergeTrees2(self, t1: TreeNode, t2: TreeNode) -\u003e TreeNode: if not t1: return t2 if not t2: return t1 root = TreeNode(-1) root.val = t1.val + t2.val root.left = self.mergeTrees2(t1.left, t2.left) root.right = self.mergeTrees2(t1.right, t2.right) return root 思路二代码如下： class Solution: # 迭代，修改树结构(t1) def mergeTrees3(self, t1: TreeNode, t2: TreeNode) -\u003e TreeNode: if t1 is None: return t2 if t2 is None: return t1 # 这里也可以不用元组结构，但是需要同时pull和push两树对应的节点 queue = [(t1, t2)] while queue: n1, n2 = queue.pop(0) # 进队列的都不为空,直接赋值相加 n1.val += n2.val # 如果节点的左子节点都不为空，则都进队列 if n1.left and n2.left: queue.append((n1.left, n2.left)) # 由于是合并到t1，不需要考虑t2左子节点为空,t1左子节点不为空的情况 if not n1.left: n1.left = n2.left # 右节点同理 if n1.right and n2.right: queue.append((n1.right, n2.right)) if not n1.right: n1.right = n2.right return t1 翻转二叉树 信息 翻转一棵二叉树。 示例： 输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 方法 这道题的主要思路就是从上到下交换子树，再交换子树的子树，循环下去……，把每一个节点的子树交换后，即可。所以核心的任务就是遍历节点了，不管是用递归还是迭代，都行。 思路一：递归，包括前序遍历、中序遍历、后序遍历 思路二：迭代，层次遍历，把节点一个个放在队列中 思路一代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 自己想的方法，直接交换镜像位置的节点的值，但是有些案例跑不通，费解…… # return root # def invert(node1, node2): # if not node1 and not node2: # return # elif not node1 and node2: # node1 = TreeNode(node2.val) # node2 = TreeNode(None) # elif not node2 and node1: # node2 = TreeNode(node1.val) # node1 = TreeNode(None) # else: # node1.val, node2.val = node2.val, node1.val # invert(node1.left, node2.right) # invert(node1.right, node2.left) # invert(root.left, root.right) # return root # 递归：前序遍历 def invertTree1(self, root: TreeNode) -\u003e TreeNode: if root is None: return root # 先交换当前节点的左右子树 root.left, root.right = root.right, root.left # 递归左子节点 self.invertTree1(root.left) # 递归右子节点 self.invertTree1(root.right) return root # 递归：中序遍历 def invertTree2(self, root: TreeNode) -\u003e TreeNode: if root is None: return root # 先交换左子节点 self.invertTree2(root.left) # 再交换当前节点 root.left, root.right = root.right, root.lef","date":"2020-08-21","objectID":"/%E5%AF%B9%E7%A7%B0%E5%90%88%E5%B9%B6%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["Python","leetcode"],"title":"对称、合并、翻转二叉树二叉树","uri":"/%E5%AF%B9%E7%A7%B0%E5%90%88%E5%B9%B6%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["学习"],"content":"Linux中vim命令的一些常用功能……","date":"2020-08-20","objectID":"/linux-vim%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/","tags":["Linux"],"title":"Linux中vim的使用","uri":"/linux-vim%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"},{"categories":["学习"],"content":" vi和vim都是Linux中的编辑器，不同的是vim比较高级，可以视为vi的升级版本。vi使用于文本编辑，但是vim更适用于coding。 1、三种模式 命令模式 黄绿色 插入模式 命令模式下输入 i ，变蓝色 。按ESC退出插入模式，回到命令模式 行末模式（底线模式） 命令模式下输入 : 三种模式的互相变换如图所示： 2、进入vim vim \u003c文件名\u003e # 进入或创建文件； 所有文件都能用vim打开 3、退出vim 在末行模式下： :q 退出 :wq 保存并退出 :wq! 强制保存并退出 :q! 强制退出 4、移动光标 gg,:0 光标转到首行行首 G, :$ 光标转到末行行首 0 光标移到本行行首 $ 光标移到本行行尾 H 光标定位到屏幕顶部 M 光标定位到屏幕中间 L 光标定位到屏幕底部 ctrl+f 下翻一屏 ctrl+b 上翻一屏 w 光标向前移动一个单词 b 光标向后移动一个单词 e 光标移动到当前单词的结尾 5、输入（插入） 命令模式下： i 从光标所在位置前开始插入 I 在当前非空格行首插入 a 从光标所在位置后面开始输入 A在当前行尾还是输入 o 在光标所在行下方新增一行并输入模式 O 在当前上面一行插入 6、删除与复制 命令模式下： 命令字符 介绍 dd(双击d) 剪切当前行 num + dd(双击d) 剪切当前行（例如10dd可以删除10行） yy 拷贝当前行 p 将内容粘贴至光标所示位置 u 撤销 Ctrl+r 反撤销 7、块状操作 命令模式下： v 块选择 Ctrl+v 列块选择 （输入命令后移动光标选择区域） 多行注释 命令模式下：Ctrl+v 选择要注释的行， shift+i ，输入# 然后再按两次ESC 8、搜索与替换 命令模式下： /内容 向前搜索内容 （向下） ?内容 向后搜索内容 （向上） n 向下查找 N 向上查找 :s/s1/s2 替换当前行的第一个s1为s2 :s/s1/s2/g 替换当前行中所有s1为s2 :%s/s1/s2/g 替换文中所有的s1为s2 vim搜索设置高亮 1、临时设置：vim打开文档--\u003e命令行形式输入：set hlsearch。 缺点：关闭文档后，下次打开，又需要重新设置一遍。 2、永久设置（推荐）：在~/.vimrc中配制--\u003evim ~/.vimrc--\u003e在文件中加上set hlsearch--\u003e然后保存退出便可。 优点：一次设置，永久生效。 ","date":"2020-08-20","objectID":"/linux-vim%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/:0:0","tags":["Linux"],"title":"Linux中vim的使用","uri":"/linux-vim%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"},{"categories":["学习"],"content":"理解并实现BFS和DFS……","date":"2020-08-19","objectID":"/bfs%E5%92%8Cdfs/","tags":["Python","算法"],"title":"BFS和DFS","uri":"/bfs%E5%92%8Cdfs/"},{"categories":["学习"],"content":" BFS（Breadth First Search）：广度优先搜索 DFS（Depth First Search）：深度优先搜索 如图为一个树结构： BFS 宽度优先搜索(又称广度优先搜索)，实际上就是层次遍历，先访问上一层，在访问下一层，一层一层的往下访问，所以搜索结果是： 实现过程：队列，先进先出 步骤 1、首先A入队列 –[A] 2、A出队列时，A的邻接结点B，C相应进入队列 –[B, C] 3、B出队列时，B的邻接结点D，E进入队列 –[C, D, E] 4、C出队列时，C的邻接结点F进入队列 –[D, E, F] 5、D出队列 –[E, F] 6、E出队列 –[F] 7、F出队列 –[] 代码如下： def bfs(self): # 先添加根节点 queue = [self.root] while queue: # push先进来的节点 cur_node = queue.pop(0) print(cur_node.element) # 加入左子结点 if cur_node.lchild: queue.append(cur_node.lchild) # 加入右子节点 if cur_node.rchild: queue.append(cur_node.rchild) DFS 深度优先搜索，说白了就是先一个劲向下，沿着**“树根”**遍历搜索 具体就是先访根节点，然后左结点，一直往下，直到最左结点没有子节点的时候然后往上退一步到父节点，然后父节点的右子节点在重复上面步骤……，所以搜索结果是： 实现过程：栈，先进后出 步骤 1、首先A入栈 –[A] 2、A出栈时，A的邻接结点C，B（注意顺序）相应进入栈 –[C, B] 3、B出栈时，B的邻接结点E、D进入栈 –[C, E, D] 4、D出栈 –[C, E] 5、E出栈 –[C] 6、C出栈时，C的邻接结点F进入栈 –[F] 7、F出栈 –[] 代码如下： def dfs(self, root): # 添加根节点 stack = [root] while stack: # 先进栈的出栈 node = stack.pop() # 左节点入栈 if node.left: stack.append(node.left) # 右节点入栈 if node.right: stack.append(node.right) ","date":"2020-08-19","objectID":"/bfs%E5%92%8Cdfs/:0:0","tags":["Python","算法"],"title":"BFS和DFS","uri":"/bfs%E5%92%8Cdfs/"},{"categories":["学习"],"content":"Python实现求二叉树的最小深度……","date":"2020-08-18","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6/","tags":["Python","leetcode"],"title":"二叉树的最小深度","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6/"},{"categories":["学习"],"content":" 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回它的最小深度2 思路一：递归 前面我们已经做过树的最大深度，所以直接把求max 改成求min， 需要注意的是 最大深度是根节点到最下面的一个子节点的路径长度，而最小深度则是根节点到最近的叶子节点的长度。 举个简答的例子，[1, 2]，这个的最小高度不是1，是2，因为1不是叶子节点，只有左右子节点都为空的节点才是叶子节点。 所以我们不能单纯地把max改成 min，还要增加一下判断边界条件，如果有子树为空，只能返回另一个子树的高度 代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def minDepth(self, root: TreeNode) -\u003e int: if root is None: return 0 # 必须是到叶子节点 # 左子节点为空，当前节点不为叶子节点，继续从右子节点找 if root.left is None and root.right is not None: return 1 + self.minDepth(root.right) # 右子节点为空，当前节点不为叶子节点，继续从左子节点找 elif root.left is not None and root.right is None: return 1 + self.minDepth(root.left) else: return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 思路二：BFS 广度优先遍历，从根节点开始，找到第一个叶子节点就return 每遍历完一层depth就+1，中间节点用队列存储 代码如下： class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def bfs(self, root): if root is None: return 0 queue = [root] depth = 1 while queue: length = len(queue) for i in range(length): node = queue.pop(0) # 遇到叶子节点就退出 if node.left is None and node.right is None: return depth if node.left: queue.append(node.left) if node.right: queue.append(node.right) # 一层循环结束，深度+1 depth += 1 ","date":"2020-08-18","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6/:0:0","tags":["Python","leetcode"],"title":"二叉树的最小深度","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6/"},{"categories":["教程"],"content":"解决github打不开，github.io访问被拒的问题……","date":"2020-08-17","objectID":"/github%E8%AE%BF%E9%97%AE/","tags":["github"],"title":"github打不开，github.io访问被拒……","uri":"/github%E8%AE%BF%E9%97%AE/"},{"categories":["教程"],"content":"github打不开 最近遇到github打不开的问题，如图，一直以为被q了…… 百度之后发现，主要是GitHub那些网址IP更换了， 电脑里的C:\\Windows\\System32\\drivers\\etc中的host文件中DNS解析都已经过期了， 解决方法就是在网站https://ipchaxun.com/ ，输入github.com查询新的IP…… 对应的把下面的内容复制到C:\\Windows\\System32\\drivers\\etc路径的host文件中 # GitHub Start 140.82.114.4 github.com 140.82.114.4 gist.github.com 185.199.108.153 assets-cdn.github.com 151.101.64.133 raw.githubusercontent.com 151.101.108.133 gist.githubusercontent.com 151.101.108.133 cloud.githubusercontent.com 151.101.108.133 camo.githubusercontent.com 151.101.108.133 avatars0.githubusercontent.com 151.101.108.133 avatars1.githubusercontent.com 151.101.108.133 avatars2.githubusercontent.com 151.101.108.133 avatars3.githubusercontent.com 151.101.108.133 avatars4.githubusercontent.com 151.101.108.133 avatars5.githubusercontent.com 151.101.108.133 avatars6.githubusercontent.com 151.101.108.133 avatars7.githubusercontent.com 151.101.108.133 avatars8.githubusercontent.com # GitHub End 在重新访问https://github.com，问题解决。 github.io访问被拒 自己是用Gitpage搭建自己的个人博客，但是在没有tz的时候总是无法访问，直接重击我搭建博客的耐心…… 还是百度一下（百度不行，就Google），原因好像是电信运营商 DNS 污染（域名指往不正确的IP地址）， 可以通过修改 hosts文件 / 修改DNS服务器 / 代理 的方式访问。 操作简单的，可将 DNS 修改为 114.114.114.114，我改完后就可以访问了。 具体操作如下（win10）： 1、打开控制面板，点击网络和共享中心 2、点击更改适配器设置 3、选择自己连接的网络，右键 –\u003e 属性 4、选择Internet协议版本4(TCP/IPv4)，点击属性，点选使用下面的DNS服务器地址（E），输入114.114.114.114，点击确定，收工。 再访问博客，就能访问了。 ","date":"2020-08-17","objectID":"/github%E8%AE%BF%E9%97%AE/:0:0","tags":["github"],"title":"github打不开，github.io访问被拒……","uri":"/github%E8%AE%BF%E9%97%AE/"},{"categories":["学习"],"content":"利用Python递归实现平衡二叉树的判断……","date":"2020-08-16","objectID":"/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/","tags":["leetcode","Python"],"title":"平衡二叉树判断","uri":"/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/"},{"categories":["学习"],"content":" 题目 一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。给定一个二叉树，判断它是否是高度平衡的二叉树。 示例如下： 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 返回 true 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 思路一：暴力迭代 从本质上讲，要求所有子树的高度差不大于1， 所以我们直接暴力求解，遍历所有节点的左右子树高度，求差，看是否符合要求。 代码： class Solution: # 求高度 def getHight(self, node): if node is None: return 0 else: return max(self.getHight(node.left), self.getHight(node.right)) + 1 # 暴力遍历每个节点的左右子树高度差 def isBalanced1(self, root: TreeNode) -\u003e bool: if root is None: return True # 判断左右子树是否平衡，如果平衡，看高度差是否大于1 if (self.isBalanced1(root.left) and self.isBalanced1(root.right) and abs(self.getHight1(root.left) - self.getHight1(root.right)) \u003c= 1): return True else: return False 思路二：自下而上递归 递归，实际上对思路一的优化， 思路一中存在大量重复的计算，按理说只需要从下往上计算一次就应该可以判断出来， 设置一个全局变量flag = True， 递归地计算每一层左右子树的高度，遇到差值大于1的，更改全局变量flag = False， 最后返回全局变量。 代码如下： class Solution: # 定义全局控制变量 def __init__(self): self.flag = True # 从下往上的一次性递归判断 def isBalanced2(self, root): self.getHight2(root) return self.flag def getHight2(self, node): if node is None: return 0 left = self.getHight2(node.left) right = self.getHight2(node.right) if abs(left-right) \u003e 1: self.flag = False return max(left, right) + 1 问题 其实上述递归的方法还有一个缺点就是没有在发现已经不是平衡树的时候提前退出递归， 网上大多给出的方法是通过对全局变量来捕获异常，但是捕获异常的机制反而导致运行时间更长，不如直接一层层退出递归。 思路三：多值递归 思路二需要设置一个全局变量， 我们可以让返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的bool类型的值 代码如下： # 定义返回的结果类，包括树的深度和子树是否平衡的bool值 class Result: def __init__(self, detpth, isb): self.detpth = detpth self.isb = isb class Solution: def main(self, root): # 最后返回\"返回值\"的布尔值 return self.isBalanced3(root).isb def isBalanced3(self, node): if node is None: return Result(0, True) left = self.isBalanced3(node.left) right = self.isBalanced3(node.right) # 非平衡的情况：任意子树不平衡、左右子树高度差大于1 if left.isb is False or right.isb is False: return Result(0, False) if abs(left.detpth - right.detpth) \u003e 1: return Result(0, False) return Result(max(left.detpth, right.detpth)+1, True) ","date":"2020-08-16","objectID":"/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/:0:0","tags":["leetcode","Python"],"title":"平衡二叉树判断","uri":"/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A4%E6%96%AD/"},{"categories":["学习"],"content":"Python实现求二叉树的最大深度……","date":"2020-08-14","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/","tags":["Python","leetcode"],"title":"二叉树的最大深度","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"},{"categories":["学习"],"content":"给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明： 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7] 3 / \\ 9 20 / \\ 15 7 最近做了一些题，看到总有人利用递归的思想解决问题，深深地被套娃😂吸引，拒绝套娃真香…… 树本身就是套娃，天生适合递归的结构。 这里给出别人的优秀总结!!!：递归三部曲 找终止条件。 什么情况下递归结束？（一般n为0或者1），这里当然是树为空的时候，此时树的深度为0，递归就结束了。 找返回值。 应该返回什么？（一般为所求目标的同类型值）题目求的是树的最大深度，需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此返回值应该是当前树的最大深度，这一步可以结合第三步来看。 本级递归应该做什么。 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是最简单的样子。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度x和y。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度max(x,y)+1，然后再返回这个深度即可。 root(max(x,y)+1) / \\ (x)left right(y) 代码如下： class Solution: def maxDepth(self, root: TreeNode) -\u003e int: if root is None: return 0 left_deepth = self.maxDepth(root.left) right_deepth = self.maxDepth(root.right) return max(left_deepth, right_deepth) + 1 ","date":"2020-08-14","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/:0:0","tags":["Python","leetcode"],"title":"二叉树的最大深度","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6/"},{"categories":["logs"],"content":"特别祝愿博客中另一位大写的人顺顺顺~~~冲冲冲~~~","date":"2020-08-13","objectID":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/","tags":[],"title":"望如我们所愿","uri":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/"},{"categories":["logs"],"content":"2020年的疫情，着实让全球人类颤了一下…… 活着的感觉真好~😄 但是没有疾病的生活也很难…… 需要工作，需要挣钱，需要吃饭~😭 社会不好混也就算了…… 为啥社会的大门都这么难进~🙃 不过…… 活着的感觉真好~😄 所以…… 还是要好好努力😋 虽然没有背景，本事一般…… 但是彼此最重要~😘 加油找到理想的工作，加油活出精彩的人生！@Y ","date":"2020-08-13","objectID":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/:0:0","tags":[],"title":"望如我们所愿","uri":"/2020-8-13-%E6%9C%9B%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%84%BF/"},{"categories":["学习"],"content":"Python实现查找数组中重复的数字……","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"信息 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 ： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 ","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"思路一：哈希表 遍历所有的元素，发现不在哈希表内的元素，直接放入哈希表内，否则，return当前元素 代码如下： def findRepeatNumber(self, nums: List[int]) -\u003e int: dic = {} for i in nums: if i not in dic: dic[i] = 1 else: return i ","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:1","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"思路二：数组内查找 思路一消耗了额外的内存空间，如果要求空间复杂度为O(1)，则只能在数组内查找 由于元素的大小小于len(nums)，则可以根据列表的索引和元素一一对应的关系来查找重复，如果没有重复，那么元素就一一对应索引，否则，元素与索引就存在多对一的关系。 代码如下： def findRepeatNumber(self, nums: List[int]) -\u003e int: for index, value in enumerate(nums): if index != value: if value == nums[value]: return value # 由于交换的过程中value会变化，所以需要提前记录一下value的值 temp = value value, nums[temp] = nums[temp], value ","date":"2020-08-12","objectID":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:2","tags":["Python","剑指offer"],"title":"查找数组中重复的数字","uri":"/%E5%89%91%E6%8C%87offer-03%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["学习"],"content":"Python实现合并有序链表……","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"信息 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-\u003e2-\u003e4;1-\u003e3-\u003e4 输出：1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4 ","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/:0:0","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"思路一：迭代 合并有序链表其实和归并排序中合并有序序列一模一样，所以可以完全参照归并排序， 就是不断比较两个链表的头节点，如果某一个链表迭代完成，另一个链表还有节点，直接指向剩余的链表即可。 代码： class ListNode: def __init__(self, val=None, next=None): self.val = val self.next = next class Solution: # 迭代 def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u003e ListNode: newlist = ListNode(None) # head为指向头部的游标 head = newlist while l1 and l2: if l1.val \u003c l2.val: head.next = ListNode(l1.val) l1 = l1.next else: head.next = ListNode(l2.val) l2 = l2.next # 注意游标的位置要不断后移 head = head.next # 这里可以优化一下，直接head.next = l1 or l2就行，因为有序 # head.next = l1 or l2 while l1: head.next = ListNode(l1.val) l1 = l1.next head = head.next while l2: head.next = ListNode(l2.val) l2 = l2.next head = head.next return newlist.next ","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/:1:0","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"思路二：递归 递归：递归是逆向思维，先理清逻辑关系，再返回实际结果 以[1,2,3]和[4,5,6]为例 先对比头结点1和4，很明显1放在最前面， 后面的结果如何先不管，但是逻辑上，只需要求出[2,3]和[4,5,6]的合并结果[……]，然后1--\u003e[……]即可， 继续求[……]…… 对比2和4，很明显2在前面，以此类推，具体过程如下： merge([1,2,3], [4,5,6]) 1 -- \u003e merge([2,3], [4,5,6]) ​ 2 -- \u003e merge([3], [4,5,6]) ​ 3 -- \u003e merge([], [4,5,6]) ​ [4,5,6] ==\u003e[1,2,3,4,5,6] 代码： class ListNode: def __init__(self, val=None, next=None): self.val = val self.next = next class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u003e ListNode: # 终止条件 if not l1: return l2 if not l2: return l1 if l1.val \u003c l2.val: l1.next = self.mergeTwoLists2(l1.next, l2) # 哪个链表开头就返回哪个链表 return l1 else: l2.next = self.mergeTwoLists2(l2.next, l1) return l2 可以明显发现，递归给人的感觉更加简洁，但是相对理解起来也更加有难度。 ","date":"2020-08-11","objectID":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/:2:0","tags":["Python","leetcode"],"title":"合并有序链表","uri":"/%E5%90%88%E5%B9%B6%E9%93%BE%E8%A1%A8/"},{"categories":["学习"],"content":"Python输出集合的所有子集……","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"目标 lst = [1, 2, 3] --\u003e [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]] ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:0","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"思路一：循环 对于任何一个集合，我们先从一个空集合[[]]开始，然后一个个添加元素， 从1开始，本来是空集[[]]，加入1 --\u003e [[1]]， 但是不能忘记空集，因为[1]的所有子集为[[], [1]]， 所以加入一个1后的集合应该是[[], [1]], 加入2，需要先把2加入已经存在的每一个子集，得到[2],[1,2] 然后合并原来的集合 [[], [1], [2], [1,2]] 以此类推，新加入一个元素，合并原来所有子集，新加入一个元素，合并原来所有子集…… 最后得出 [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]] 代码如下： def allsubsets1(lst): result = [[]] if len(lst) == 0: return result for i in range(len(lst)): for item in result[:]: result.append(item+[lst[i]]) print(len(result)) return result ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:1","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"思路二：递归 递归的本质与循环相同，只不过换了一种形式， 递归是一种逆向思维， 如果想要[1, 2, 3]的所有子集，需要知道[1,2]的子集， 继而需要[1]的子集，[]的子集， 然后在最后一层的子集中加入新元素，再合并子集，加入新元素，合并子集…… 代码如下： def allsubsets2(lst): if len(lst) == 0: return [[]] else: # 这里等同于 result.append(item+[lst[i]]) return allsubsets2(lst[1:]) + [[lst[0]] + i for i in allsubsets2(lst[1:])] ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:2","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"思路三：位运算 将子集与二进制映射 0 [] –\u003e 0000 1[1] –\u003e 0001 2 [2] –\u003e 0010 3 [1, 2] –\u003e 0011 可以发现，所有子集其实就是所有元素位置为1或0的排列。 我们知道len(lst)=N的集合子集总数为2^N个， 而list(range(2^N))正好一一对应所有子集为1或0的排列。 代码如下： def allsubsets3(lst): result = [] if len(lst) == 0: return [[]] # 遍历0~2^n-1 for i in range(2 \u003c\u003c (len(lst)-1)): tmp = [] # 遍历每位是否为1 for j in range(len(lst)): if i \u003e\u003e j \u0026 1 == 0: tmp.append(lst[j]) result.append(tmp) print(len(result)) return result ","date":"2020-08-10","objectID":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/:0:3","tags":["Python","算法"],"title":"集合所有子集","uri":"/%E9%9B%86%E5%90%88%E5%AD%90%E9%9B%86/"},{"categories":["学习"],"content":"Python位运算的用法……","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"Python位运算符 按位运算符是把数字看作二进制来进行计算的 Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13 a = 0011 1100 b = 0000 1101 ----------------- a\u0026b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 \u0026 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a \u0026 b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1 (a \\| b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 « 左移动运算符：运算数的各二进位全部左移若干位，由 « 右边的数字指定了移动的位数，高位丢弃，低位补0。 a \u003c\u003c 2 输出结果 240 ，相当于a*2^2二进制解释： 1111 0000 » 右移动运算符：把\"»\"左边的运算数的各二进位全部右移若干位，» 右边的数字指定了移动的位数 a \u003e\u003e 2 输出结果 15 ，相当于a/2^2二进制解释： 0000 1111 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"应用实例 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"1 交换两个变量 # 两个相同的数异或之后结果会等于 0，即 n ^ n = 0。并且任何数与 0 异或等于它本身，即 n ^ 0 = n。 x = x ^ y // （1） y = x ^ y // （2） x = x ^ y // （3） ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:1","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"2 判断奇偶数 n \u0026 1 == 1 与 n % 2 类似 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:2","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"3 找出没有重复的数 给一组整型数据，这些数据中，其中有一个数只出现了一次，其他的数都出现了两次，让你来找出一个数 。 思想：两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身，所以我们把这一组整型全部异或一下 lst = [1, 2, 3, 3, 4, 4, 2, 1, 5, 5, 6] def unique(lst): temp = lst[0] for i in range(1, len(lst)): temp ^= lst[i] return temp print(unique(lst)) ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:3","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"4 m的n次方 1、直接用pow函数 # math模块 import math math.pow(x, y) ------------------------------ #　内置的pow()方法 pow(x, y[, z]) #　函数是计算x的y次方，如果z在存在，则再对结果进行取模 #　其结果等效于pow(x,y) %z 特别注意一下 pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。 2、循环 def powxy(x, y): tmp = 1 for i in range(y): tmp *= x return tmp 时间复杂度为 O(n)，有没有其他优化的方法呢？ 3、位运算 把n转成二进制，如n=9，——\u003e1001，求m的9次方， 即m^9 = m^1000 * m^0001，所以只需要把是1的乘数累积到结果中 如2^9，拆分为1000，0001（8,1） def powerXn(x, n): result = 1 temp = x while n != 0: if n \u0026 1 == 1: result *= temp temp *= temp n \u003e\u003e= 1 return result 4、递归 递归计算幂方，二分优化，2^6 = 2^3*2^3，故可以二分求幂 def powerXn(x, n): if n == 0: return 1 else: temp = powerX1(x, n//2) result = temp * temp if n % 2 == 1: result *= x return result ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:4","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"5 不大于N的最大2的幂指数 传统的做法就是让1不断着乘以 2，代码如下： def findN(n): sum = 1 while True: if sum * 2 \u003e n: return sum sum *= 2 时间复杂度是O(logn)，还有其他优化的方法吗？ 采用位运算：例如 N = 19，那么转换成二进制就是 00010011。那么我们要找的数就是，把二进制中最左边的1保留，后面的 1 全部变为 0。即我们的目标数是 00010000 1、找到最左边的 1，然后把它右边的所有 0 变成 1 2、把得到的数值加 1，可以得到 00100000即 00011111 + 1 = 00100000。 3、把得到的 00100000 向右移动一位，即可得到 00010000，即 00100000 » 1 = 00010000。 具体的做法为： n |= n \u003e\u003e 1 n |= n \u003e\u003e 2 n |= n \u003e\u003e 4 n |= n \u003e\u003e 8 我们假设最左边的 1 处于二进制位中的第 k 位(从左往右数),那么把 n 右移一位之后，那么得到的结果中第 k+1 位也必定为 1,然后把 n 与右移后的结果做或运算，那么得到的结果中第 k 和 第 k + 1 位必定是 1;同样的道理，再次把 n 右移两位，那么得到的结果中第 k+2和第 k+3 位必定是 1,然后再次做或运算，那么就能得到第 k, k+1, k+2, k+3 都是 1，如此往复下去…. 完整代码： def findN(n): n |= n \u003e\u003e 1 n |= n \u003e\u003e 2 n |= n \u003e\u003e 4 n |= n \u003e\u003e 8 return(n+1) \u003e\u003e 1 ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:5","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"6 输出集合的子集 以lst = [1,2,3,4]为例，将子集与二进制映射。可以发现，所有子集其实就是所有元素位置为1或0的排列。我们知道len(lst)=N的集合子集总数为2^N个，而list(range(2^N))正好一一对应所有子集为1或0的排列。 0 [] --\u003e 0000 1 [1] --\u003e 0001 2 [2] --\u003e 0010 3 [1, 2] --\u003e 0011 4 [3] --\u003e 0100 5 [1, 3] --\u003e 0101 6 [2, 3] --\u003e 0110 7 [1, 2, 3] --\u003e 0111 8 [4] --\u003e 1000 9 [1, 4] --\u003e 1001 10 [2, 4] --\u003e 1010 11 [1, 2, 4] --\u003e 1011 12 [3, 4] --\u003e 1100 13 [1, 3, 4] --\u003e 1101 14 [2, 3, 4] --\u003e 1110 15 [1, 2, 3, 4] --\u003e 1111 具体的代码： def findsubsets(lst): N = len(lst) for i in range(2 ** N):#子集的个数 subset = [] for j in range(N):#用来判断二进制数的下标为j的位置的数是否为1 if (i \u003e\u003e j) \u0026 1: subset.append(lst[j]) print(subset) ","date":"2020-08-09","objectID":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/:2:6","tags":["Python"],"title":"Python位运算","uri":"/python%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["学习"],"content":"Python高级函数filter、map、reduce……","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":" filter、map、reduce，都是对一个集合进行处理，filter 用于过滤，map 用于映射，reduce 用于归并。是 Python 列表方法的三架马车。 ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:0:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"1 filter filter会根据提供的函数对指定序列做过滤。 filter 函数的定义：filter(function or None, sequence) -\u003e list, tuple, or string function 是一个谓词函数，接受一个参数，返回布尔值 True 或 False。 filter 函数会对序列参数 sequence 中的每个元素调用 function 函数，最后返回的结果包含调用结果为 True 的元素。 返回值的类型和参数 sequence 的类型相同 比如返回序列中的所有偶数： def is_even(x): return x \u0026 1 != 0 filter(is_even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \u003e\u003e\u003e[1, 3, 5, 7, 9] 注意 如果 function 参数为 None，返回结果和 sequence 相同。 filter(None, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) \u003e\u003e\u003e[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:1:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"2 map map 函数会根据提供的函数对指定序列做映射。 map 函数的定义：map(function, sequence[, sequence, ...]) -\u003e list 通过定义可以看到，这个函数的第一个参数是一个函数，剩下的参数是一个或多个序列，返回值是一个集合。 function 可以理解为是一个一对一或多对一函数，map 的作用是以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的 list。 比如要对一个序列中的每个元素进行平方运算： map(lambda x: x ** 2, [1, 2, 3, 4, 5]) [1, 4, 9, 16, 25] 在参数存在多个序列时，会依次以每个序列中相同位置的元素做参数调用 function 函数。 比如要对两个序列中的元素依次求和。 map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) map 返回的 list[0] :参数序列 1 的第一个元素加参数序列 2 中的第一个元素 (1 + 2) list[1]:参数序列 1 中的第二个元素加参数序列 2 中的第二个元素 (3 + 4) …… 依次类推，最后的返回结果为：[3, 7, 11, 15, 19] 要注意 function 函数的参数数量，要和 map 中提供的集合数量相匹配。 而且如果集合长度不相等，会以最小长度对所有集合进行截取。 技巧 当函数为 None 时，操作和 zip 相似： map(None, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) \u003e\u003e\u003e[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)] ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:2:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"3 reduce reduce 函数会对参数序列中元素进行累积 reduce 函数的定义：reduce(function, sequence[, initial]) -\u003e value function 参数是一个有两个参数的函数，reduce 依次从 sequence 中取一个元素，和上一次调用 function 的结果做参数再次调用 function。 注意 第一次调用 function 时，如果提供 initial 参数，会以 sequence 中的第一个元素和 initial 作为参数调用 function，否则会以序列 sequence 中的前两个元素做参数调用 function。 from functools import reduce #已经从全局命名空间删除，需要从functools导入 reduce(lambda x, y: x + y, [2, 3, 4, 5, 6], 1) #1为initial参数 结果为 21 ((((((1+2)+3)+4)+5)+6)) reduce(lambda x, y: x + y, [2, 3, 4, 5, 6]) 结果为 20 注意 function 函数不能为 None。 ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:3:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"4 应用实例 4.1、用 map 和 reduce 实现 5 的阶乘相加（5!+4!+3!+2!+1!） \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,6))) 120 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,5))) 24 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,4))) 6 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,3))) 2 \u003e\u003e\u003eprint (reduce(lambda x,y:x*y,range(1,2))) 1 把上一步的结果变成一个阶乘列表 \u003e\u003e\u003eprint(map(lambda a:reduce(lambda x,y:x*y,range(1,a+1)),range(1,6))) [1, 2, 6, 24, 120] 最后把阶乘列表相加，第一题解决 \u003e\u003e\u003eprint(reduce(lambda m,n:m+n,map(lambda a:reduce(lambda x,y:x*y,range(1,a+1)),range(1,6)))) 153 4.2、用 filter 将 100~200 以内的质数过滤出来 质数，又称素数，指在一个大于 1 的自然数中，除了 1 和此整数自身外，不能被其他自然数整除的数 \u003e\u003e\u003elist(filter(lambda x:len(list(filter(lambda y:x%y==0,range(2,int(x**0.5)+1))))==0,range(23,30))) #不能直接对迭代器使用len()函数，先转化为list ","date":"2020-08-08","objectID":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/:4:0","tags":["Python"],"title":"Python filter,map,reduce","uri":"/python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0filter-map-reduce/"},{"categories":["学习"],"content":"Linux挂载的解释……","date":"2020-08-08","objectID":"/linux%E6%8C%82%E8%BD%BD/","tags":["Linux"],"title":"Linux挂载","uri":"/linux%E6%8C%82%E8%BD%BD/"},{"categories":["学习"],"content":"信息 名词解释： 挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。 Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中，输入 tree /即可查看 在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构） 当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为linux所用。合二为一的过程称为“挂载”。 注意 Windows下，mount挂载，就是给磁盘分区提供一个盘符（C,D,E,...）。比如插入U盘后，系统自动分配I或E或者其他的盘符，盘符其实就是挂载，退优盘的时候进行安全弹出，其实就是卸载：unmount。 问题 Linux下，不像Windows可以有C,D,E多个目录，Linux只有一个根目录/。在装系统时，分配给linux的所有区都在/下的某个位置，比如/home等等。 具体挂载的过程看下面的例子 示例 以插入硬盘为例，假如插入了新硬盘，分了新磁盘区sdb1。它现在还不属于/，如图所示： 目前 U 盘和 Linux 系统文件分属两个文件系统，还无法使用命令行找到 U 盘文件，需要将两个文件系统进行挂载。 虽然可以在一些Linux图形桌面系统里找到位置，浏览管理里面的文件，但在命令行却不知道怎么访问，比如无法使用cd或者ls。更无法在编程时指定一个目录对其操作。 接下来，我们在根目录下新建一个目录 /sdb-u，通过挂载命令将 U 盘文件系统挂载到此目录，如图所示： 挂载命令：mount /sdb1 /sdb-u 把U盘的区sdb1挂载到Linux根目录的/sdb-u文件夹下，之后访问这个/sdb-u文件夹就相当于访问这个U盘了。对/sdb-u的任何操作，都相当于对U盘里文件的操作。 所以直白讲，Linux下，mount挂载的作用，就是将一个设备（通常是存储设备）挂接到一个已存在的目录上，访问这个目录就是访问该存储设备。 linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。 要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。 挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。 问题 插入U盘后不是自动分盘到/sdb1 吗，直接对它操作不就行了？这不是它的目录吗？ /sdb1不是目录。可以发现ls /sdb1无法执行。/sdb1是一个类似指针的东西，指向这个分区的原始数据块。mount前，系统并不知道这个数据块哪部分数据代表文件，也不知道如何对它们操作。 技巧 插入CD，系统其实自动执行了 mount /dev/cdrom /media/cdrom。所以可以直接在系统的/media/cdrom中对CD中的内容进行管理。 ","date":"2020-08-08","objectID":"/linux%E6%8C%82%E8%BD%BD/:0:0","tags":["Linux"],"title":"Linux挂载","uri":"/linux%E6%8C%82%E8%BD%BD/"},{"categories":["学习"],"content":"SQL的学习笔记……","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"1、了解SQL SQL：Structured Query Language（结构 化查询语言）的缩写。 SQL 是一种专门用来与数据库沟通的语言。 注意 主键（primary key）： 一列（或一组列），其值能够唯一标识表中每一行。 任意两行都不具有相同的主键值； 每一行都必须具有一个主键值（主键列不允许 NULL 值）； 主键列中的值不允许修改或更新； 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:1:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"2、检索数据 select column_name1, column_name2, ... -- '*'用来检索所有列 from table -- SQL 语句不区分大小写 -- distinct column_name 检索去重后的结果 注意：不能部分使用 DISTINCT DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例 如，你指定 SELECT DISTINCT vend_id, prod_price，除非指定的 两列完全相同，否则所有的行都会被检索出来。 -- limit m, n 表示从m+1行开始，偏移n行 MySQL和 MariaDB支持简化版的 LIMIT 4 OFFSET 3 语句，即 LIMIT 3,4。 使用这个语法，逗号之前的值对应 OFFSET，逗号之后的值对应 LIMIT。 第一个被检索的行是第 0 行，而不是第 1 行。因此， LIMIT 1 OFFSET 1 会检索第 2 行，而不是第 1 行。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:2:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"3、排序检索数据 order by 注意： ORDER BY 子句的位置 在指定一条 ORDER BY 子句时，应该保证它是 SELECT 语句中最后一条子句 按多个列排序 order by column_name1, column_name2 仅在多个行具有相同的 column_name1 值时才对产品按 column_name2 进行排序。如果 column_name1 列中所有的值都是唯一的，则不会按 column_name2 排序。 多个列排序时还可以采用相对位置来排序，order by 2, 3 -- 2,3代表第2列和第3列 排序 默认：ASC，升序排列 DESC 关键字只应用到直接位于其前面的列名，如果想在多个列上进行降序排序，必须对每一列指定 DESC 关键字。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:3:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"4、过滤数据 在 SELECT 语句中，数据根据 WHERE 子句中指定的搜索条件进行过滤 在同时使用 ORDER BY 和 WHERE 子句时，应该让 ORDER BY 位于WHERE 之后 范围内查询 between ... and ... -- 数值或者日期范围内查询 select column_name1, column_name2 from table where column_name2 between 5 and 10; -- BETWEEN 匹配范围中所有的值，包括指定的开始值和结束值。 确定值是否为 NULL，不能简单地检查是否= NULL， 用is null 判断 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:4:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"5、高级数据过滤 组合where语句： SQL 允许给出多个 WHERE 子句。这些子句有两种使用方式，即以 AND 子句或 OR 子句的方式使用， and优先级高 IN 操作符后跟由逗号分隔的合法值，这些值必须括在圆括号中 信息 为什么要使用 IN 操作符？其优点如下 在有很多合法选项时， IN 操作符的语法更清楚，更直观。 在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。 IN 操作符一般比一组 OR 操作符执行得更快。 IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立 WHERE 子句。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:5:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"6、用通配符进行过滤 匹配like开头的字符 like 'like%' %代表搜索模式中给定位置的 0 个、 1 个或多个字符。 注意： NULL通配符%看起来像是可以匹配任何东西，但有个例外，这就是 NULL。 子句 WHERE prod_name LIKE '%' 不会匹配产品名称为 NULL 的行。 另一个有用的通配符是下划线（ _）。 下划线的用途与%一样，但它只匹配单个字符，而不是多个字符。 -- 说明：Access 通配符如果使用的是 Microsoft Access，需要使用 ?而不是_。 方括号（ [] ）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。 说明：并不总是支持集合与前面描述的通配符不一样，并不是所有 DBMS 都支持用来创建集合的[]。 只有微软的 Access 和 SQL Server 支持集合。 WHERE cust_contact LIKE '[JM]%' -- 找出所有名字以 J 或 M 起头的联系人 此通配符可以用前缀字符 ^（脱字号）来否定。 例如，下面的查询匹配以J 和 M 之外的任意字符起头的任意联系人名（与前一个例子相反） WHERE cust_contact LIKE '[ ^JM]%' -- 以J 和 M 之外的任意字符起头的任意联系人名 可以用not 代替 WHERE NOT cust_contact LIKE '[JM]%' 注意 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用 其他操作符。 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:6:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"7、创建计算字段 将值联结到一起（将一个值附加到另一个值）构成单个值。 根据你所使用的 DBMS，此操作符可用加号（ +）或两个竖杠（ || ）表示。 在 MySQL 和 MariaDB 中，必须使用特殊的函数。 -- Access 和 SQL Server 使用 +号。 DB2、 Oracle、 PostgreSQL、 SQLite 和Open Office Base 使用 || 如： SELECT vend_name + ' (' + vend_country + ')' --或 SELECT vend_name || ' (' || vend_country || ')' FROM Vendors ORDER BY vend_name; 下面是使用 MySQL 或 MariaDB 时需要使用的语句： SELECT Concat(vend_name, ' (', vend_country, ')') -- 按顺序放在concat函数内 FROM Vendors ORDER BY vend_name; --大多数 DBMS 都支持 RTRIM()（正如刚才所见，它去掉字符串右边的空格） --LTRIM()（去掉字符串左边的空格） --以及 TRIM()（去掉字符串左右两边的空格 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:7:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"8、使用函数处理数据 UPPER()将文本转换为大写 LEFT()（或使用子字符串函数） 返回字符串左边的字符 LENGTH()（也使用DATALENGTH()或LEN()） 返回字符串的长度 LOWER()（ Access使用LCASE()） 将字符串转换为小写 LTRIM() 去掉字符串左边的空格 RIGHT()（或使用子字符串函数） 返回字符串右边的字符 RTRIM() 去掉字符串右边的空格 SOUNDEX() 返回字符串的SOUNDEX值 --发音相似 WHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green') UPPER()（ Access使用UCASE()） 将字符串转换为大写 日期：WHERE strftime('%Y', order_date) = '2012'; ABS() 返回一个数的绝对值 COS() 返回一个角度的余弦 EXP() 返回一个数的指数值 PI() 返回圆周率 SIN() 返回一个角度的正弦 SQRT() 返回一个数的平方根 TAN() 返回一个角度的正切 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:8:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"9、汇总数据 AVG() 返回某列的平均值 -- AVG()函数忽略列值为 NULL 的行 COUNT() 返回某列的行数 -- 使用 COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（ NULL）还是非空值。 -- 使用 COUNT(column)对特定列中具有值的行进行计数， 忽略 NULL 值 MAX() 返回某列的最大值 -- MAX()函数忽略列值为 NULL 的行 MIN() 返回某列的最小值 -- MIN()函数忽略列值为 NULL 的行 SUM() 返回某列值之和 -- 如SELECT SUM(item_price*quantity) AS total_price， SUM()函数忽略列值为 NULL 的行 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:9:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"10、分组数据 GROUP BY 子句和 HAVING 子句 如果分组列中包含具有 NULL 值的行，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组 WHERE 在数据分组前进行过滤， HAVING 在数据分组后进行过滤，WHERE 排除的行不包括在分组中 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:10:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"11、使用子查询 SELECT cust_id FROM Orders WHERE order_num IN (SELECT order_num -- WHERE order_num IN (20007,20008) FROM OrderItems WHERE prod_id = 'RGAN01'); 对于检索出的每个顾客，统计其在 Orders 表中的订单数目 SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders FROM Customers ORDER BY cust_name; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:11:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"12、联结表 可以联结多个表返回一组输出，联结在运行时关联表中正确的行 子查询可以用联接表实现，联接表需要注意where条件语句，否则返回为笛卡尔积 SELECT prod_name, vend_name, prod_price, quantity FROM OrderItems, Products, Vendors WHERE Products.vend_id = Vendors.vend_id AND OrderItems.prod_id = Products.prod_id AND order_num = 20007; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:12:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"13、创建高级联接 子查询： SELECT cust_id, cust_name, cust_contact FROM Customers WHERE cust_name = (SELECT cust_name FROM Customers WHERE cust_contact = 'Jim Jones') 联接查询： SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM Customers AS c1, Customers AS c2 WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones'; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:13:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"14、组合查询 利用 UNION 操作符将多条 SELECT 语句组合成一个结果集 SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN ('IL','IN','MI') UNION SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = 'Fun4All'; --使用 UNION 时，重复的行会被自动取消。使用 UNION ALL， DBMS 不取消重复的行 注意 UNION 必须由两条或两条以上的 SELECT 语句组成，语句之间用关键 字 UNION 分隔（因此， 如果组合四条 SELECT 语句，将要使用三个 UNION 关键字）。 UNION 中的每个查询必须包含相同的列、表达式或聚集函数（不过， 各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含 转换的类型（例如，不同的数值类型或不同的日期类型） ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:14:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"15、数据插入 insert into table(a, b, c) values('xx', 'xx', 'xx') INSERT INTO Customers VALUES('1000000006', 'Toy Land', '123 Any Street', 'New York', 'NY', '11111', 'USA', NULL, NULL); --提示：插入多行 INSERT 通常只插入一行。要插入多行，必须执行多个 INSERT 语句。 INSERT SELECT是个例外，它可以用一条 INSERT插入多行，不管 SELECT语句返回多少行，都将被 INSERT 插入 select * into b from a -- 把a数据复制到b ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:15:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"16、更新和删除数据 利用 UPDATE 和 DELETE 语句进一步操作表数据 update table set xx=xx where ... UPDATE Customers SET cust_email = 'kim@thetoystore.com' WHERE cust_id = '1000000005'; --删除一行 DELETE FROM Customers WHERE cust_id = '1000000006'; DELETE 语句从表中删除行，甚至是删除表中所有行。但是， DELETE不删除表本 --删除一列 alter table 表名 drop column 列名 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:16:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"17、创建和操纵表 create table table_name( column_name1 type, column_name2 type, ... ); CREATE TABLE Products ( prod_id CHAR(10) NOT NULL, vend_id CHAR(10) NOT NULL, prod_name CHAR(254) NOT NULL, prod_price DECIMAL(8,2) NOT NULL, prod_desc VARCHAR(1000) NULL ); 更改表结构 增加一列：ALTER TABLE VendorsADD vend_phone CHAR(20); 删除一列：ALTER TABLE Vendors DROP COLUMN vend_phone; 删 除 表：DROP TABLE CustCopy； 重命名表：rename table old_name to new_name; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:17:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"18、使用视图 视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据 注意：性能问题 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。 如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。 因此，在部署使用了大量视图的应用前，应该进行测试。 1、与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字） 2、对于可以创建的视图数目没有限制 3、视图不能索引，也不能有关联的触发器或默认值 视图用 CREATE VIEW 语句来创建 DROP VIEW viewname 删除视图 视图一般是一个复杂的sql查询 -- create view view_name as select ...... CREATE VIEW ProductCustomers AS SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; 视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。 视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理， 重新格式化或保护基础数据 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:18:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"19、使用存储过程 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。 存储过程可封装，并隐藏复杂的商业逻辑。 存储过程可以回传值，并可以接受参数。 存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。 存储过程可以用在数据检验，强制实行商业逻辑等 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:19:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"20、事务管理 事务（ transaction）指一组 SQL 语句； 回退（ rollback）指撤销指定 SQL 语句的过程； 提交（ commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（ savepoint）指事务处理中设置的临时占位符（ placeholder）， 可以对它发布回退（与回退整个事务处理不同）。 使用简单的 ROLLBACK 和 COMMIT 语句，就可以写入或撤销整个事务。但 是，只对简单的事务才能这样做，复杂的事务可能需要部分提交或回退。在 SQL 中，这些占位符称为保留点。在 MariaDB、 MySQL 和 Oracle 中 创建占位符，可使用 SAVEPOINT 语句。 ....... savepoint my_savepoint1 ....... savepoint my_savepoint2 ....... rollback to my_savepoint1 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:20:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"21、使用游标 游标是面向集合与面向行的设计思想之间的一种桥梁，主要用在循环处理、存储过程、函数中使用，用来查询结果集 游标的使用一般分为 5 个步骤，主要是：定义游标 -\u003e 打开游标 -\u003e 使用游标 -\u003e 关闭游标 -\u003e 释放游标。 （1）定义游标 语法为： DECLARE \u003c游标名\u003e CURSOR FOR select语句; 具体例子： DECLARE mycursor CURSOR FOR select * from shops_info; -- 这样游标就对select语句声明了一个游标 （2）打开游标 open \u003c游标名\u003e （3）使用游标 使用游标需要用关键字 fetch 来取出数据，然后取出的数据需要有存放的地方，我们需要用 declare 声明变量存放列的数据其语法格式为： declare 变量1 数据类型(与列值的数据类型相同) declare 变量2 数据类型(与列值的数据类型相同) declare 变量3 数据类型(与列值的数据类型相同) FETCH [NEXT | PRIOR | FIRST | LAST] FROM \u003c游标名\u003e [ INTO 变量名1,变量名2,变量名3[,…] ] NEXT： 取下一行的数据，游标一开始默认的第一行之前， 故要让游标指向第一行，就必须第一次就执行 FETCH NEXT 操作 INTO：将一行中每个对应的列下的数据放到与列 的数据类型相同的变量中。 -- 声明四个变量 declare id varchar(20); declare pname varchar(20); declare pprice varchar(20); declare pdescription varchar(20); 总结： 1、定义一个游标mycursor declare mycursor cursor forselect *from shops_info; 2、打开游标： open mycursor; 3、使用游标获取列数据放入变量中 fetch next from mycursor into id,pname,pprice,pdescription; 4、关闭游标：很简单的使用语句： close mycursor; 5、释放游标： deallocate mycursor; ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:21:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"22、高级SQL特性 高级数据处理特性： 约束、 索引和触发器 检查约束 CREATE TABLE OrderItems ( order_num INTEGER NOT NULL, order_item INTEGER NOT NULL, prod_id CHAR(10) NOT NULL, quantity INTEGER NOT NULL CHECK (quantity \u003e 0), --检查保证 quantity大于 0。 item_price MONEY NOT NULL ); 检查名为 gender 的列只包含 M 或 F，可编写如下的 ALTER TABLE 语句： ADD CONSTRAINT CHECK (gender LIKE '[MF]') 触发器是特殊的存储过程，它在特定的数据库活动发生时自动执行。触发 器可以与特定表上的 INSERT、 UPDATE 和 DELETE 操作（或组合）相关联。 sql serve版本： CREATE TRIGGER customer_state ON Customers FOR INSERT, UPDATE AS UPDATE Customers SET cust_state = Upper(cust_state) WHERE Customers.cust_id = inserted.cust_id; 一般来说，约束的处理比触发器快，因此在可能的时候，应该尽量使用约束。 ","date":"2020-08-06","objectID":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/:22:0","tags":["SQL"],"title":"SQL学习","uri":"/sql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"categories":["学习"],"content":"经典十大排序算法的Python实现……","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"本文是关于经典排序算法的个人学习记录……，文字部分网上都有，算是个人总结复制粘贴，重点在代码部分。 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"概述 排序算法是《数据结构与算法》中最基本的算法之一。 排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 用一张图概括： 关于时间复杂度： 平方阶 (O (n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序； 线性对数阶 (O (nlog2n)) 排序 快速排序、堆排序和归并排序； O (n1+§)) 排序，§ 是介于 0 和 1 之间的常数。希尔排序； 线性阶 (O (n)) 排序 基数排序，此外还有桶、箱排序。 关于稳定性： 排序后 2 个相等键值的顺序和排序之前它们的顺序相同 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 名词解释： n：数据规模 k：“桶” 的个数 In-place：占用常数内存，不占用额外内存，原地算法，仅靠输出覆盖输入，即对原数组进行操作 Out-place：占用额外内存 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"1 冒泡排序 冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。 （1）算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 （2）动图演示 （3）python 代码 '''前后两个对比，一次排出一个最值放在最后''' def bubble_sort(arr): for i in range(1, len(arr)): for j in range(0, len(arr)-i): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] else: continue return arr 技巧 立个flag '''优化：每次循环后需要监测是否发生了数据交换，如果没有，则可以提前结束排序''' def bubble_sort_plus(arr): for i in range(1, len(arr)): flag = True for j in range(0, len(arr)-i): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] flag = False else: continue if flag: break return arr 每次循环时记录最后一次交换的位置 '''常见的数据中大部分是部分有序，尾部部分有序的数据更多，可以继续优化： 每次循环时记录最后一次交换的位置，位置之后的说明部分有序，不需要再交换了，只对前面的数据排序''' def bubble_sort_plus2(arr): end = len(arr) start = 1 while start \u003c end: sorted_index = 0 #初始值为0是为了已排序列表，保证一次循环就结束 for j in range(0, end-start): if arr[j] \u003e arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] sorted_index = j+1 #记录截止排序的地方，即后面全是有序列表， start = 0 #记录之后，start为0，保证下次循环，end-start可以取到记录之前所有的数 end = sorted_index #记录赋值给end，保证while循环次数中去掉记录之后的循环 start += 1 #正常循环递增 return arr bubble_sort_plus2(arr) \"\"\"冒泡排序算法是稳定，但是如果把比较过程的\u003c写出\u003c=就会导致不稳定\"\"\" ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"2 选择排序 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O (n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。 （1）算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 （2）动图演示 （3）python代码 '''每次循环选择剩余数组中的最小值，在左侧排列好''' def select_sort(arr): for i in range(len(arr)): min_index = i for j in range(i+1, len(arr)): if arr[j] \u003c arr[min_index]: min_index = j if i != min_index: arr[i], arr[min_index] = arr[min_index], arr[i] return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"3 堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。其实是对选择排序的一种优化，把内部循环寻找最值的工作交给堆结构 （1）算法步骤 创建一个堆 H [0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down (0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 （2）动图演示 （3）python代码 '''借用堆结构，利用大顶堆筛选出最值，弹出最值，递归剩余数组，不断弹出最值''' def heapify(arr, n, i): large = i left = 2 * i + 1 right = 2 * i + 2 if left \u003c n and arr[large] \u003c arr[left]: large = left if right \u003c n and arr[large] \u003c arr[right]: large = right if large != i: arr[i], arr[large] = arr[large], arr[i] heapify(arr, n, large) def heap_sort(arr): n = len(arr) for i in range(n//2, -1, -1): #从最后一个非根节点开始，由下到上，逐渐堆化 heapify(arr, n, i) for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) #每次交换最大值和末尾值后，需要对0节点进行shiftdown操作，重新堆化 return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"4 插入排序 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 （1）算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） （2）动图演示 （3）python 代码 '''右侧未排序的不断与已排序的左侧逐一比较，小于则已排序的往后移一位''' def insert_sort(arr): for i in range(1,len(arr)): pre_index = i-1 current = arr[i] #记录当前值 while pre_index \u003e= 0 and arr[pre_index] \u003e current: arr[pre_index+1] = arr[pre_index] #这里直接用大数往后挪位，而不是采用交换（交换一次实际需要执行三次赋值操作），可以减少代码执行，提高效率 pre_index -= 1 arr[pre_index+1] = current return arr 技巧 继续优化插入排序：由于插入的过程中前面已经有序，可以利用二分搜索计算插入的位置，而不是一个个比较，但是挪动的次数不变，只是比较的次数减少，所以时间复杂度依然是O(n^2)。同时还要注意的是：2,4,5,6,6,6,6,7,9,6，如果把最后一个6插入前面，如果只是用二分搜索，可能导致算法不稳定（因为二分计算的索引不确定），所以需要有所改动，在原来二分搜索的基础上，计算第一个比插入值大的值的索引，即：7的索引，如图所示，在原来二分搜索的基础上，把=m的情况归并到\u003em的情况中，最后迭代到begin=end，返回begin或end。 二分搜索时，begin和end的位置一般是左闭右开[begin,end)，end一般是超出列表索引后一位，即等于列表长度，目的是可以算出中间元素的个数=end-begin，如图所示： 二分搜索的代码： '''二分搜索一般用来查找有序数列中某一数字的位置，代码如下''' arr = [0,1,2,3,4,5,6,7,8,9,10] num = 10 def binary_search(arr, num): ''' arr:搜索的列表 num:搜索的数 ''' begin = 0 end = len(arr) while begin \u003c end: mid = (begin+end) // 2 if num \u003e arr[mid]: begin = mid + 1 elif num \u003c arr[mid]: end = mid else: return mid return -1 binary_search(arr, num) 插入排序二分搜索优化如图： 优化的代码如下： def binary_search(arr, index): begin = 0 end = index while begin \u003c end: mid = (begin+end) // 2 if arr[index] \u003e= arr[mid]: begin = mid + 1 else: end = mid return begin #其实最后的begin和end相等，也就是待插入的索引位置 def insert_sort(arr): for i in range(1,len(arr)): current = arr[i] insert_index = binary_search(arr, i) while i \u003e insert_index: #对当前索引和插入索引之间的数据进行挪位 arr[i] = arr[i-1] i -= 1 arr[insert_index] = current return arr insert_sort(arr[:]) ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"5 希尔排序 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； （1）算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti \u003e tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 （2）动图演示 （3）Python 代码 '''分组采用插入排序，步长逐渐减小，为1时已经大部分有序，再经过最后一次插入排序；不稳定''' def shell_sort(arr): gap = len(arr) // 2 while gap \u003e 0: for i in range(gap, len(arr)): temp = arr[i] j = i - gap while j \u003e= 0 and arr[j] \u003e temp: arr[j+gap] = arr[j] j -= gap arr[j+gap] = temp gap //= 2 return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"6 归并排序 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O (nlogn) 的时间复杂度。代价是需要额外的内存空间。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法） 自下而上的迭代 （1）算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 （2）动图演示 （3）python代码 '''分而治之，迭代分组后，不同分组排序后归并，需要申请额外的存储空间''' def merge_sort(arr): if len(arr)\u003c2: return arr mid = len(arr) // 2 left, right = arr[:mid], arr[mid:] return merge(merge_sort(left), merge_sort(right)) def merge(left, right): result = [] while left and right: if left[0] \u003c right[0]: result.append(left.pop(0)) else: result.append(right.pop(0)) while left: result.append(left.pop(0)) while right: result.append(right.pop(0)) return result ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"7 快速排序 快速排序是由东尼・霍尔所发展的一种排序算法。快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 信息 快速排序虽然 Worst Case 的时间复杂度达到了 O (n²)，但是在大多数情况下都比平均时间复杂度为 O (n logn) 的排序算法表现要更好，在《算法艺术与信息学竞赛》上的解释：快速排序的最坏运行情况是 O (n²)，比如说顺序数列的快排。但它的平摊期望时间是 O (nlogn)，且 O (nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O (nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 （1）算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； （2）动图演示 （3）python 代码 '''一、随机挑选一个基准，然后根据分大小区，迭代上述，把分区和基准连接在一起返回 本质就是把每一个元素转换成轴点元素，数组就排好序了''' def quick_sort(arr): if len(arr) \u003c= 1: return arr else: pivot = arr[0] left = [x for x in arr[1:] if x \u003c pivot] right = [x for x in arr[1:] if x \u003e= pivot] return quick_sort(left) + [pivot] + quick_sort(right) 在原数组上进行交换 '''二、在原数组上进行交换的写法''' def quick_sort(arr): sort(0, len(arr)) #对[0,len(arr))范围内的数组进行排序 def sort(begin, end): if end-begin \u003c 2: return mid = pivotIndex(begin, end) sort(begin, mid) sort(mid+1, end) def pivotIndex(begin, end): pivot = arr[begin] #以第一个元素为轴点 end -= 1 while begin \u003c end: '''需要来回左右比较判断，可以用while嵌套''' while begin \u003c end: if arr[end] \u003e pivot: end -= 1 else: arr[begin] = arr[end] begin += 1 break while begin \u003c end: if arr[begin] \u003c pivot: begin += 1 else: arr[end] = arr[begin] end -= 1 break arr[begin] = pivot return begin 具体过程如图： 最坏情况是O(n^2)，如图所示： 技巧 为了防止出现上述最坏的时间复杂度，我们需要随机选取轴点元素，这里操作的方法是，随机选取数组中的元素和begin位置的元素进行调换即可。 import random '''三、在原数组上进行交换的写法，加上随机选取轴点数据''' def quick_sort(arr): sort(0, len(arr)) #对[0,len(arr))范围内的数组进行排序 def sort(begin, end): if end-begin \u003c 2: return mid = pivotIndex(begin, end) sort(begin, mid) sort(mid+1, end) def pivotIndex(begin, end): '''随机选取元素与begin位置元素交换''' pivot = random.choice(arr) #以第一个元素为轴点 end -= 1 while begin \u003c end: '''需要来回左右比较判断，可以用while嵌套''' while begin \u003c end: if arr[end] \u003e pivot: end -= 1 else: arr[begin] = arr[end] begin += 1 break while begin \u003c end: if arr[begin] \u003c pivot: begin += 1 else: arr[end] = arr[begin] end -= 1 break arr[begin] = pivot return begin 虽然与轴点相等的元素可以放在任意一边，但是最好将与轴点相等的元素扔到对面的分组，这样可以保持分组的均匀，否则分组可能非常不均匀，最后的时间复杂度就很高。 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"8 计数排序 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 （1）动图演示 （2）Python 代码 '''针对有确定范围的整数数组，统计不同整数的个数存放在额外的存储空间，按整数大小排序''' def count_sort(arr): bucket_len = max(arr) + 1 bucket = [0] * bucket_len sort_index = 0 for i in range(len(arr)): bucket[arr[i]] += 1 for j in range(bucket_len): while bucket[j] \u003e 0: arr[sort_index] = j sort_index += 1 bucket[j] -= 1 return arr 技巧 上面的方法无法对负整数排序，极其浪费内存空间并且不稳定 节省空间\u0026对负整数排序 #节省空间\u0026对负整数排序：max-min+1 def count_sort(arr): buckets = [0] * ((max(arr) - min(arr))+1) min_num = min(arr) for i in range(len(arr)): buckets[arr[i]-min_num] += 1 res=[] for i in range(len(buckets)): if buckets[i] != 0: res += [i+min(arr)]*buckets[i] return res 稳定排序 ''' 稳定排序:稳定排序需要遍历原数组， 同时需要记录该元素前面元素的个数（就是本元素的索引）， 所以现在不是记录每个元素的个数，而是记录小于等于该元素的个数， 如[2,3,5,1,5,7,8],则新建的索引为每个元素-最小值（k-min）， 每个索引对应是值为\u003c=k的元素数（原来是=k），从右往左依次遍历原数组， 如8，索引为7，值为7，排序后的索引为7-1，右边的5：索引为4， 值为5， 排序后的索引为5-1， 左边的5：索引和值相同，排序后的索引为5-1-1， 从右往左遍历保证了稳定性。 ''' def count_sort(arr): buckets = [0] * ((max(arr) - min(arr))+1) min_num = min(arr) for i in range(len(arr)): buckets[arr[i]-min_num] += 1 for j in range(1, len(buckets)): buckets[j] = buckets[j] + buckets[j-1] res=[0] * len(arr) for k in range(len(arr)-1, -1, -1): res[buckets[arr[k]-min_num]-1] = arr[k] buckets[arr[k]-min_num] -= 1 return res ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"9 桶排序 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 什么时候最快：当输入的数据可以均匀的分配到每一个桶中。 什么时候最慢：当输入的数据被分配到了同一个桶中。 （1）Python 代码 '''将数组分到顺序的桶内（划分范围）,对桶内数据排序后，合并在一起''' def heap_sort(arr): min_num = min(arr) max_num = max(arr) bucket_range = (max_num - min_num) / len(arr) bucket_list = [[] for i in range(len(arr)+1)] for i in arr: bucket_list[int((i-min_num) // bucket_range)].append(i) arr.clear() for i in bucket_list: arr += sorted(i) return arr ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"10 基数排序 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数（低位到高位）分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 由于每位数的取值范围是固定的0~9，所以针对每次排序，可以用计数排序 信息 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； （1）动图演示 （2）python 代码 '''针对比较集中的整数数组，分别根据不同位上的数分箱（0~9）,然后排序，递归上述步骤''' def radix_sort(arr): i = 0 n = 1 max_num = max(arr) while max_num \u003e 10 ** n: n += 1 while i \u003c n: bucket = {} for x in range(10): bucket.setdefault(x, []) for y in arr: radix = int(y / (10**i) % 10) bucket[radix].append(y) arr.clear() for j in range(10): if len(bucket[j]) != 0: arr += bucket[j] i += 1 return arr 信息 未完待续…… ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"11 Timsort ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:12:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"12 休眠排序 ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:13:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["学习"],"content":"13 拓扑排序 …… ","date":"2020-08-05","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:14:0","tags":["排序算法","Python"],"title":"经典排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["logs"],"content":"人长大了，感情就淡了……","date":"2020-08-04","objectID":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/","tags":[],"title":"长大的烦恼","uri":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/"},{"categories":["logs"],"content":"人长大了，感情就淡了…… 多次发现曾经很要好的人，已经许久不再联系。 拿起手机发个消息，突然发现大家都不在是以前的大家。 我以为我的突然问候能让彼此回想起很多事。 事实却是感情淡了，更多的是尬聊。 大家，还有我，都有了新的圈子。 好像每个人都在变。 唯一不变的就是我们都在变。 还是不要再自作多情。 过好自己最重要。 以前的自己多么幼稚，希望今后越来越成熟， 不要倾诉太多，不要掏心掏肺。 毕竟以后…… 我们不再是以前的我们。 ","date":"2020-08-04","objectID":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/:0:0","tags":[],"title":"长大的烦恼","uri":"/2020-8-4-%E9%95%BF%E5%A4%A7%E7%9A%84%E7%83%A6%E6%81%BC/"},{"categories":[],"content":"这是一个关于个人的学习记录和生活日常的博客小站~","date":"2020-08-04","objectID":"/about/","tags":[],"title":"关于本博客","uri":"/about/"},{"categories":[],"content":"好好学习，天天向上 摘要 信息 本人是个半宅男，爱好电子产品、游戏、动漫、肥宅快乐水…… 一直都不爱写笔记，不管是在读书上课或者自学软件和技术，都觉得记笔记是一件十分耽误时间的事，更重要的是笔记就特别像手机里的照片，舍不得删，也一直不看……😂 但随着学习的东西越来越多，发现如果在学习的时候不输出一点笔记和总结，那学习新的东西真的痛苦，学这忘那是常事，互相记混才是真的烦……😩 所以……，好好记笔记吧，养成喜欢记笔记和总结的好习惯，是真的香！！！🤙 而且，笔记中穿插着个人总结，会让你不自觉中对学习的内容掌握地更加熟练……， 因此，本着好好学习，天天向上的乐观向上自我催眠主义，搭建了这个博客，感谢LoveIt主题 这里推荐一下笔记的工具和笔记分享途径 markdown：非常方便且好看的文本格式 typora（Vscode）：大力推荐的编辑markdown工具 hugo：大力推荐的静态网页生成工具 github（gitlab）：代码仓库以及网页访问（gitpage） 当然了，博客的作用当然不仅仅是分享笔记，生活常事、所见所闻、学习记录、心中所感这些都可以分享，分享是一件快乐的事……🤗 ","date":"2020-08-04","objectID":"/about/:0:0","tags":[],"title":"关于本博客","uri":"/about/"},{"categories":["学习"],"content":"个人的一些算法学习记录和总结……","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"注意 多看、多想、多做、多练、多总结！！！ ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:0:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"1 辗转相除法求最大公约数 原理： 两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。具体可见wiki 例如，252 和 105 的最大公约数是 21；因为 252 − 105 = 21 × (12 − 5) = 147 所以 147 和 105 的最大公约数也是 21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 21 = 5 × 105 + (−2) × 252 。这个重要的结论叫做裴蜀定理。 思想：不断求较小数与两数余数的最大公约数，实际上是大数不断地减去小数，最后保留的数就是最大公约数 Python实现 '''普通计算''' m = int(input('please input a number:')) n = int(input('please input a number:')) max_n, min_n = max(m, n), min(m, n) r = max_n % min_n while r != 0: max_n = min_n min_n = r r = max_n % min_n print('最大公约数：',min_n) '''利用递归''' def highcf(m, n): m, n = max(m, n), min(m, n) r = m % n if r == 0: return n else: return highcf(n, r) # 单独写highcf(n, r)可以计算出结果，但是没有返回值 '''直接使用math.gcd()''' ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:1:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"2 质数判断 思想：除以2一直到平方根，都除不尽就是质数 import math # 用户输入数字 num = int(input(\"请输入一个数字: \")) if num \u003e 1: # 质数大于 1 square_num = math.floor( num ** 0.5 ) # 找到其平方根（ √ ），减少算法时间 for i in range(2, (square_num+1)): #将平凡根加1是为了能取到平方根那个值 if (num % i) == 0: print(num, \"是合数\") print(i, \"乘于\", num // i, \"是\", num) break else: print(num, \"是质数\") else: # 如果输入的数字小于或等于 1，不是质数 print(num, \"既不是质数，也不是合数\") ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:2:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"3 范围内素数计算 思想：在范围内迭代进行质数判断 def get_prime_number(lower, bigger): for num in range(lower, bigger+1): if num \u003e 1: sqrt = int(num ** 0.5) for i in range(2, sqrt+1): if num % i == 0: break else: yield num else: return lower = int(input('please input a lower number:')) bigger = int(input('please input a bigger number:')) lst = [i for i in get_prime_number(lower, bigger)] print(lst) '''骚气的filter一行语法糖''' list(filter(lambda x:len(list(filter(lambda y:x%y==0,range(2,int(x**0.5)+1))))==0,range(100,150))) #100-150之内的质数 ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:3:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"4 实现斐波那契数列 思想：迭代和递归 '''递归''' def fab(n): if n == 1: return 0 if n == 2: return 1 else: return fab(n-1)+fab(n-2) list(map(fab,range(1, 10))) \u003e\u003e\u003e[0, 1, 1, 2, 3, 5, 8, 13, 21] '''迭代''' def fab(n): arr = [0,1] a, b = 0, 1 while a \u003c n: a, b = b, a+b arr.append(a) return arr fab(10) \u003e\u003e\u003e[0, 1, 1, 1, 2, 3, 5, 8, 13] ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:4:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"5 最小公倍数 思想： 两个数的最小公倍数等于两数乘积除以最大公约数 先看大数是否能整除小数，不能的话，就是大数的整倍数 \"\"\"两个数的最小公倍数等于两数乘积除以最大公约数\"\"\" def lcm(b,s): m = b*s while (b!=0) and (s!=0): b, s = s, b%s return m//b print(lcm(b,s)) print(lcm(12,8)) \u003e\u003e\u003e24 \"\"\"先看大数是否能整除小数，不能的话，就是大数的整倍数\"\"\" def lcm(a, b): #a\u003eb count = 2 if a%b == 0: return a else: while a*count % b != 0: count += 1 return a*count print(lcm(12, 8)) ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:5:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"6 约瑟夫环问题 30 个人在一条船上，超载，需要 15 人下船。于是人们排成一队，排队的位置即为他们的编号。 报数，从 1 开始，数到 9 的人下船，然后下一个从1开始。如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？ 思想：把不相关的元素挪到列表尾部，每挪8个元素后，就把下一个元素剔除掉 def josephus(nums, step, stay): '''nums:总人数; step:摇号下船; stay:留在船上的人数''' lst = list(range(1, nums+1)) drop = [] while len(lst) \u003e stay: i = 1 while i \u003c step: lst.append(lst.pop(0)) i += 1 drop.append(lst.pop(0)) return drop josephus(30, 9, 28) \u003e\u003e\u003e[9, 18, 27, 6, 16, 26, 7, 19, 30, 12, 24, 8, 22, 5, 23] ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:6:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"7 五人分鱼问题 A、B、C、D、E 五人在某天夜里合伙去捕鱼，到第二天凌晨时都疲惫不堪，于是各自找地方睡觉。日上三杆，A 第一个醒来，他将鱼分为五份，把多余的一条鱼扔掉，拿走自己的一份。B 第二个醒来，也将鱼分为五份，把多余的一条鱼扔掉拿走自己的一份。 C、D、E 依次醒来，也按同样的方法拿鱼。问他们台伙至少捕了多少条鱼？ 思想：暴力增加鱼的个数，保证连续五次满足分鱼条件 def get_fish(): fish = 1 while True: total = fish #不能直接操作fish，导致死循环，要用total变量代替 for _ in range(5): if (total-1) % 5 == 0: total = (total-1)//5*4 else: break else: #for else 结构，for循环必须完全遍历完成后才会执行else语句，保证五次分鱼 return fish fish += 1 get_fish() ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:7:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"},{"categories":["学习"],"content":"8 两变量交换 在不采用第三变量的情况下，交换两个变量的值 思想： 采用加减法 位运算（相同的数异或为0，与0异或为本身） a = a + b; b = a - b; a = a - b; ------------ x = x ^ y // （1） y = x ^ y // （2） x = x ^ y // （3） ","date":"2020-08-03","objectID":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/:8:0","tags":["算法","Python"],"title":"算法学习一","uri":"/%E8%8F%9C%E9%B8%9F%E5%AE%9E%E4%BE%8B/"}]